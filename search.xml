<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>机器学习01 - 绪论</title>
      <link href="/2018/09/11/machine-learning-01/"/>
      <url>/2018/09/11/machine-learning-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>teach-skill-01</title>
      <link href="/2018/09/10/teach-skill-01/"/>
      <url>/2018/09/10/teach-skill-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>我这二十多年</title>
      <link href="/2018/09/10/back-my-life/"/>
      <url>/2018/09/10/back-my-life/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Ubuntu全新安装Geth及开发智能合约 -</title>
      <link href="/2018/08/29/eth-ubu-envconfig/"/>
      <url>/2018/08/29/eth-ubu-envconfig/</url>
      
        <content type="html"><![CDATA[<h3 id="安装Geth"><a href="#安装Geth" class="headerlink" title="安装Geth"></a>安装Geth</h3><p>我们将所有的安装放置在/home/zhyunfe/下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home/zhyunfe</span><br><span class="line">mkdir geth</span><br><span class="line">git clone https://github.com/ethereum/go-ethereum</span><br><span class="line">sudo apt-get install -y build-essential golang</span><br><span class="line">cd go-ethereum</span><br><span class="line">make geth</span><br></pre></td></tr></table></figure></p><p>安装完了之后我们可以使用命令测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">zhyunfe@zhyunfe: /home/zhyunfe$ geth</span><br><span class="line">WARN [08-29|04:30:34.204] Sanitizing cache to Go&apos;s GC limits       provided=1024 updated=320</span><br><span class="line">INFO [08-29|04:30:34.879] Maximum peer count                       ETH=25 LES=0 total=25</span><br><span class="line">INFO [08-29|04:30:34.916] Starting peer-to-peer node               instance=Geth/v1.8.15-unstable-63352bf4/linux-amd64/go1.10.1</span><br><span class="line">INFO [08-29|04:30:34.919] Allocated cache and file handles         database=/home/zhyunfe/.ethereum/geth/chaindata cache=240 handles=512</span><br><span class="line">INFO [08-29|04:30:35.448] Initialised chain configuration          config=&quot;&#123;ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: &lt;nil&gt; Engine: ethash&#125;&quot;</span><br><span class="line">INFO [08-29|04:30:35.785] Disk storage enabled for ethash caches   dir=/home/zhyunfe/.ethereum/geth/ethash count=3</span><br><span class="line">INFO [08-29|04:30:35.794] Disk storage enabled for ethash DAGs     dir=/home/zhyunfe/.ethash               count=2</span><br><span class="line">INFO [08-29|04:30:35.812] Initialising Ethereum protocol           versions=&quot;[63 62]&quot; network=1</span><br><span class="line">INFO [08-29|04:30:36.314] Loaded most recent local header          number=0 hash=d4e567…cb8fa3 td=17179869184</span><br><span class="line">INFO [08-29|04:30:36.317] Loaded most recent local full block      number=0 hash=d4e567…cb8fa3 td=17179869184</span><br><span class="line">INFO [08-29|04:30:36.318] Loaded most recent local fast block      number=0 hash=d4e567…cb8fa3 td=17179869184</span><br><span class="line">INFO [08-29|04:30:36.399] Loaded local transaction journal         transactions=0 dropped=0</span><br><span class="line">INFO [08-29|04:30:36.443] Regenerated local transaction journal    transactions=0 accounts=0</span><br><span class="line">INFO [08-29|04:30:36.453] Starting P2P networking</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu,Solidity,Python,Node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CryptoZombies以太坊学习 - 01</title>
      <link href="/2018/08/28/eth-game-01/"/>
      <url>/2018/08/28/eth-game-01/</url>
      
        <content type="html"><![CDATA[<h1 id="僵尸工场"><a href="#僵尸工场" class="headerlink" title="僵尸工场"></a>僵尸工场</h1><h3 id="第一步-设置一个空合约"><a href="#第一步-设置一个空合约" class="headerlink" title="第一步 设置一个空合约"></a>第一步 设置一个空合约</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">// 创建一个僵尸工场的空合约</span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步-状态变量和整数"><a href="#第二步-状态变量和整数" class="headerlink" title="第二步 状态变量和整数"></a>第二步 状态变量和整数</h3><p>状态变量是被永久地保存在合约中，也就是说他们被写入以太币区块链中，想象成写入一个数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    //uint 无符号数据类型，指其值不能是附属，对于有符号的整数存在名为int 的数据类型</span><br><span class="line">    // Solidity 中uint是uint256的代名词，一个256位的无符号整数 还有uint8 uint16 uint 32一般用uint就可以了</span><br><span class="line">    </span><br><span class="line">    //定义僵尸的DNA由一个十六位数字组成</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="第三步-数学运算"><a href="#第三步-数学运算" class="headerlink" title="第三步 数学运算"></a>第三步 数学运算</h3><p>加法 x + y<br>减法 x - y<br>乘法 x * y<br>除法 x / y<br>求模/取余 x % y<br>乘方 x ** y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    </span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    </span><br><span class="line">    // 为了保证我们的僵尸的DNA只含有16个字符，我们先造一个uint数据，让它等于10^16。这样一来以后我们可以用模运算符 % 把一个整数变成16位</span><br><span class="line">    // 建立一个uint类型的变量，名字叫dnaModulus 令其等于10的dnaDigits次方</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四步-结构体"><a href="#第四步-结构体" class="headerlink" title="第四步 结构体"></a>第四步 结构体</h3><p>在我们的程序中，我们将创建一些僵尸！每个僵尸将拥有多个属性，所以这是一个展示结构体的完美例子。</p><p>建立一个struct 命名为 Zombie.</p><p>我们的 Zombie 结构体有两个属性： name (类型为 string), 和 dna (类型为 uint)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    </span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    </span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    // 定义一个结构体</span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第五步-数组"><a href="#第五步-数组" class="headerlink" title="第五步 数组"></a>第五步 数组</h3><p>如果你想建立一个集合，可以用 数组这样的数据类型. Solidity 支持两种数组: 静态 数组和动态 数组:</p>   <figure class="highlight plain"><figcaption><span>固定长度为2的静态数组:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint[2] fixedArray;</span><br><span class="line">// 固定长度为5的string类型的静态数组:</span><br><span class="line">string[5] stringArray;</span><br><span class="line">// 动态数组，长度不固定，可以动态添加元素:</span><br><span class="line">uint[] dynamicArray;</span><br></pre></td></tr></table></figure><p>你也可以建立一个 结构体类型的数组 例如，上一章提到的 Person:<br>   <code>Person[] people; // dynamic Array, we can keep adding to it</code></p><p>记住：状态变量被永久保存在区块链中。所以在你的合约中创建动态数组来保存成结构的数据是非常有意义的。</p><h4 id="公共数组"><a href="#公共数组" class="headerlink" title="公共数组"></a>公共数组</h4><p>你可以定义 public 数组, Solidity 会自动创建 getter 方法. 语法如下:</p><p><code>Person[] public people;</code></p><p>其它的合约可以从这个数组读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">uint dnaDigits = 16;</span><br><span class="line">uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">struct Zombie &#123;</span><br><span class="line">    string name;</span><br><span class="line">    uint dna;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个数据类型为 Zombie 的结构体数组，用 public 修饰，命名为：zombies.</span><br><span class="line">Zombie[] public zombies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第六步-定义函数"><a href="#第六步-定义函数" class="headerlink" title="第六步 定义函数"></a>第六步 定义函数</h3><p>在 Solidity 中函数定义的句法如下:</p><p><code>function eatHamburgers(string _name, uint _amount) {}</code><br>这是一个名为 eatHamburgers 的函数，它接受两个参数：一个 string类型的 和 一个 uint类型的。现在函数内部还是空的。</p><p>注：: 习惯上函数里的变量都是以(_)开头 (但不是硬性规定) 以区别全局变量。我们整个教程都会沿用这个习惯。</p><p>我们的函数调用如下:</p><p><code>eatHamburgers(&quot;vitalik&quot;, 100);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line">    </span><br><span class="line">    //建立一个函数 createZombie。 它有两个参数: _name (类型为string), 和 _dna (类型为uint)。</span><br><span class="line">    function createZombie(string _name, uint _dna) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line">    </span><br><span class="line">    function createZombie(string _name, uint _dna) &#123;</span><br><span class="line">         //在函数体里新创建一个 Zombie， 然后把它加入 zombies 数组中。 新创建的僵尸的 name 和 dna，来自于函数的参数。</span><br><span class="line">           zombies.push(Zombie(_name, _dna));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 第八步 变为私有函数</span><br><span class="line">```solidity</span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line">    // 变为私有private </span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">         //在函数体里新创建一个 Zombie， 然后把它加入 zombies 数组中。 新创建的僵尸的 name 和 dna，来自于函数的参数。</span><br><span class="line">           zombies.push(Zombie(_name, _dna));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 第九步 函数返回值和修饰符</span><br><span class="line"></span><br><span class="line">#### 返回值</span><br><span class="line">要想函数返回一个数值，按如下定义：</span><br></pre></td></tr></table></figure><p>string greeting = “What’s up dog”;</p><p>function sayHello() public returns (string) {<br>  return greeting;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Solidity 里，函数的定义里可包含返回值的数据类型(如本例中 string)。</span><br><span class="line"></span><br><span class="line">#### 函数的修饰符</span><br><span class="line">上面的函数实际上没有改变 Solidity 里的状态，即，它没有改变任何值或者写任何东西。</span><br><span class="line"></span><br><span class="line">这种情况下我们可以把函数定义为 view, 意味着它只能读取数据不能更改数据:</span><br><span class="line"></span><br><span class="line">`function sayHello() public view returns (string) &#123;&#125;`</span><br><span class="line"></span><br><span class="line">Solidity 还支持 pure 函数, 表明这个函数甚至都不访问应用里的数据，例如：</span><br></pre></td></tr></table></figure></p><p>function _multiply(uint a, uint b) private pure returns (uint) {<br>  return a * b;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这个函数甚至都不读取应用里的状态 — 它的返回值完全取决于它的输入参数，在这种情况下我们把函数定义为 pure.</span><br><span class="line"></span><br><span class="line">注：可能很难记住何时把函数标记为 pure/view。 幸运的是， Solidity 编辑器会给出提示，提醒你使用这些修饰符。</span><br><span class="line"></span><br><span class="line">```solidity</span><br><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建一个产生随机数字的函数，不改变数据，只访问数据，使用view</span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第十步-Keccak256-和-类型转换"><a href="#第十步-Keccak256-和-类型转换" class="headerlink" title="第十步 Keccak256 和 类型转换"></a>第十步 Keccak256 和 类型转换</h3><h4 id="keccak256"><a href="#keccak256" class="headerlink" title="keccak256"></a>keccak256</h4><p>如何让 _generateRandomDna 函数返回一个全(半) 随机的 uint?</p><p>Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。字符串的一个微小变化会引起散列数据极大变化。</p><p>这在 Ethereum 中有很多应用，但是现在我们只是用它造一个伪随机数。</p><p>例子:</p><p><code>keccak256(&quot;aaaab&quot;);//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</code></p><p><code>keccak256(&quot;aaaac&quot;);//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9</code><br>显而易见，输入字符串只改变了一个字母，输出就已经天壤之别了。</p><p>注: 在区块链中安全地产生一个随机数是一个很难的问题， 本例的方法不安全，但是在我们的Zombie DNA算法里不是那么重要，已经很好地满足我们的需要了。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>有时你需要变换数据类型。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint8 a = 5;</span><br><span class="line">uint b = 6;</span><br><span class="line">// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:</span><br><span class="line">uint8 c = a * b;</span><br><span class="line">// 我们需要将 b 转换为 uint8:</span><br><span class="line">uint8 c = a * uint8(b);</span><br><span class="line">上面, a * b 返回类型是 uint, 但是当我们尝试用 uint8 类型接收时, 就会造成潜在的错误。如果把它的数据类型转换为 uint8, 就可以了，编译器也不会出错。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    &#125;</span><br><span class="line">    // 第一行代码取 _str 的 keccak256 散列值生成一个伪随机十六进制数，类型转换为 uint, 最后保存在类型为 uint 名为 rand 的变量中。</span><br><span class="line">      </span><br><span class="line">    // 我们只想让我们的DNA的长度为16位 (还记得 dnaModulus?)。所以第二行代码应该 return 上面计算的数值对 dnaModulus 求余数(%)</span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">         uint rand = uint(keccak256(_str));</span><br><span class="line">         return rand % dnaModuls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十一步-放在一起"><a href="#第十一步-放在一起" class="headerlink" title="第十一步 放在一起"></a>第十一步 放在一起</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">        zombies.push(Zombie(_name, _dna));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建一个 public 函数，命名为createRandomZombie. 它将被传入一个变量 _name (数据类型是 string)。 (注: 定义公共函数 public 和定义一个私有 private 函数的做法一样)。</span><br><span class="line">    </span><br><span class="line">    //函数的第一行应该调用 _generateRandomDna 函数，传入 _name 参数, 结果保存在一个类型为 uint 的变量里，命名为 randDna。</span><br><span class="line">    </span><br><span class="line">    //第二行调用 _createZombie 函数， 传入参数： _name 和 randDna。</span><br><span class="line">    </span><br><span class="line">    //整个函数应该是4行代码 (包括函数的结束符号 &#125; )。</span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十二步-事件"><a href="#第十二步-事件" class="headerlink" title="第十二步  事件"></a>第十二步  事件</h3><p>我们的合约几乎就要完成了！让我们加上一个事件.</p><p>事件 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。</p><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这里建立事件</span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line">function add(uint _x, uint _y) public &#123;</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  //触发事件，通知app</span><br><span class="line">  IntegersAdded(_x, _y, result);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你的 app 前端可以监听这个事件。JavaScript 实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(function(error, result) &#123; </span><br><span class="line">  // 干些事</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.19;</span><br><span class="line"></span><br><span class="line">contract ZombieFactory &#123;</span><br><span class="line"></span><br><span class="line">    // 这里建立事件</span><br><span class="line">    event NewZombie(uint zombieId, string name, uint dna);</span><br><span class="line">    uint dnaDigits = 16;</span><br><span class="line">    uint dnaModulus = 10 ** dnaDigits;</span><br><span class="line"></span><br><span class="line">    struct Zombie &#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint dna;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Zombie[] public zombies;</span><br><span class="line"></span><br><span class="line">    function _createZombie(string _name, uint _dna) private &#123;</span><br><span class="line">            // 这里触发事件,修改 _createZombie 函数使得当新僵尸造出来并加入zombies数组后，生成事件NewZombie。</span><br><span class="line">            //需要定义僵尸id。 array.push() 返回数组的长度类型是uint - 因为数组的第一个元素的索引是 0， array.push() - 1 将是我们加入的僵尸的索引。 zombies.push() - 1 就是 id，数据类型是 uint。在下一行中你可以把它用到 NewZombie 事件中。</span><br><span class="line">            uint id = zombies.push(Zombie(_name, _dna)) - 1;</span><br><span class="line">            NewZombie(id, _name, _dna);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    function _generateRandomDna(string _str) private view returns (uint) &#123;</span><br><span class="line">        uint rand = uint(keccak256(_str));</span><br><span class="line">        return rand % dnaModulus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createRandomZombie(string _name) public &#123;</span><br><span class="line">        uint randDna = _generateRandomDna(_name);</span><br><span class="line">        _createZombie(_name, randDna);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="第十三步-Web3-js"><a href="#第十三步-Web3-js" class="headerlink" title="第十三步 Web3.js"></a>第十三步 Web3.js</h3><p>我们的 Solidity 合约完工了！ 现在我们要写一段 JavaScript 前端代码来调用这个合约。</p><p>以太坊有一个 JavaScript 库，名为Web3.js。</p><p>在后面的课程里，我们会进一步地教你如何安装一个合约，如何设置Web3.js。 但是现在我们通过一段代码来了解 Web3.js 是如何和我们发布的合约交互的吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 下面是调用合约的方式:</span><br><span class="line">var abi = /* abi是由编译器生成的 */</span><br><span class="line">var ZombieFactoryContract = web3.eth.contract(abi)</span><br><span class="line">var contractAddress = /* 发布之后在以太坊上生成的合约地址 */</span><br><span class="line">var ZombieFactory = ZombieFactoryContract.at(contractAddress)</span><br><span class="line">// `ZombieFactory` 能访问公共的函数以及事件</span><br><span class="line"></span><br><span class="line">// 某个监听文本输入的监听器:</span><br><span class="line">$(&quot;#ourButton&quot;).click(function(e) &#123;</span><br><span class="line">  var name = $(&quot;#nameInput&quot;).val()</span><br><span class="line">  //调用合约的 `createRandomZombie` 函数:</span><br><span class="line">  ZombieFactory.createRandomZombie(name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 监听 `NewZombie` 事件, 并且更新UI</span><br><span class="line">var event = ZombieFactory.NewZombie(function(error, result) &#123;</span><br><span class="line">  if (error) return</span><br><span class="line">  generateZombie(result.zombieId, result.name, result.dna)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 获取 Zombie 的 dna, 更新图像</span><br><span class="line">function generateZombie(id, name, dna) &#123;</span><br><span class="line">  let dnaStr = String(dna)</span><br><span class="line">  // 如果dna少于16位,在它前面用0补上</span><br><span class="line">  while (dnaStr.length &lt; 16)</span><br><span class="line">    dnaStr = &quot;0&quot; + dnaStr</span><br><span class="line"></span><br><span class="line">  let zombieDetails = &#123;</span><br><span class="line">    // 前两位数构成头部.我们可能有7种头部, 所以 % 7</span><br><span class="line">    // 得到的数在0-6,再加上1,数的范围变成1-7</span><br><span class="line">    // 通过这样计算：</span><br><span class="line">    headChoice: dnaStr.substring(0, 2) % 7 + 1，</span><br><span class="line">    // 我们得到的图片名称从head1.png 到 head7.png</span><br><span class="line"></span><br><span class="line">    // 接下来的两位数构成眼睛, 眼睛变化就对11取模:</span><br><span class="line">    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,</span><br><span class="line">    // 再接下来的两位数构成衣服，衣服变化就对6取模:</span><br><span class="line">    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,</span><br><span class="line">    //最后6位控制颜色. 用css选择器: hue-rotate来更新</span><br><span class="line">    // 360度:</span><br><span class="line">    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),</span><br><span class="line">    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),</span><br><span class="line">    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),</span><br><span class="line">    zombieName: name,</span><br><span class="line">    zombieDescription: &quot;A Level 1 CryptoZombie&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">  return zombieDetails</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ether </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）目标文件里有什么</title>
      <link href="/2018/08/19/self-contivation-of-programmers-three/"/>
      <url>/2018/08/19/self-contivation-of-programmers-three/</url>
      
        <content type="html"><![CDATA[<p>编译器编译源代码后生成的文件叫做目标文件。</p><h3 id="3-1-目标文件的格式是什么"><a href="#3-1-目标文件的格式是什么" class="headerlink" title="3.1 目标文件的格式是什么"></a>3.1 目标文件的格式是什么</h3><p>可执行文件格式：</p><pre><code>- PE Portable Executable (windows)- ELF Executable Linkable Format (Linux)</code></pre><p>目标文件：源代码编译后但未进行链接的哪些中间文件windows下的.obj和linux下的.o</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 使用file命令查看响应的文件格式</span><br><span class="line">file filename.o</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-2-目标文件是什么样的"><a href="#3-2-目标文件是什么样的" class="headerlink" title="3.2 目标文件是什么样的"></a>3.2 目标文件是什么样的</h3><p>一般目标文件将信息按照不同的属性按照节的形式存储，有时候也叫段。<br>在一般情况下，他们都表示一个一定长度的区域，基本上不加以区分别。</p><p>代码段：.code  .text  ===&gt; 程序指令<br>数据段: .data         ===&gt; 程序数据</p><ul><li>C语言编译后的执行语句都编译成机器代码，保存在.text段</li><li>已经初始化的全局变量和局部变量都保存在.data段</li><li>未初始化的全局变量和局部静态变量默认值都为0存在.bss段，.bss段只是预留空间没有内容，不占空间<h3 id="3-3-挖掘SimpleSection-o"><a href="#3-3-挖掘SimpleSection-o" class="headerlink" title="3.3 挖掘SimpleSection.o"></a>3.3 挖掘SimpleSection.o</h3></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"%d\n"</span>, i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    func1 ( static_var + static_var2 + a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -c SimpleSection.c</code> 得到SimpleSection.o文件</p><p><code>objdump -h SimpleSection.o</code> 查看目标文件的结构和内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  <span class="number">1</span> .data         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">00000098</span>  <span class="number">2</span>**<span class="number">2</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  <span class="number">2</span> .bss          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">2</span>    没有COMMNETS 长度为<span class="number">0</span></span><br><span class="line">                  ALLOC</span><br><span class="line">  <span class="number">3</span> .rodata       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a0  <span class="number">2</span>**<span class="number">0</span>    只读数据段</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  <span class="number">4</span> .comment      <span class="number">0000002</span>e  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>a4  <span class="number">2</span>**<span class="number">0</span>    注释信息段</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">5</span> .note.GNU-<span class="built_in">stack</span> <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d2  <span class="number">2</span>**<span class="number">0</span>  堆栈提示段 长度为<span class="number">0</span></span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  <span class="number">6</span> .eh_frame     <span class="number">00000058</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="number">000000</span>d8  <span class="number">2</span>**<span class="number">3</span></span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><p>属性分析：</p><pre><code>- Size 段的长度- File Off 段的位置- CONTENTS、ALLOC等表示段的各种属性</code></pre><table><thead><tr><th>OtherData</th><th>0x00000450</th></tr></thead><tbody><tr><td>.comment</td><td>0X000000a4</td></tr><tr><td>.rodata 1</td><td>0X000000a0</td></tr><tr><td>.data</td><td>0X00000098</td></tr><tr><td>.text</td><td>0X00000040</td></tr><tr><td>ELF Header</td><td>0X00000000</td></tr></tbody></table><p>有一个专门的命令叫做size，用来查看ELF文件的代码段、数据段和BSS段的长度，dec表示3个段长度的和的十进制，hex表示长度和的十六进制</p><p><code>size SimpleSection.o</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text   data    bss    dec    hexfilename</span><br><span class="line">   180      8      4    192     c0main.o</span><br></pre></td></tr></table></figure><h4 id="3-3-1-代码段"><a href="#3-3-1-代码段" class="headerlink" title="3.3.1 代码段"></a>3.3.1 代码段</h4><p>objdump -s 参数可以将所有端的内容以16禁止的方式打印出来</p><p>-d 参数可以将所有包含指令的段反汇编</p><p><code>objdump -s -d SimpleSection.o</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> <span class="number">0000</span> <span class="number">554889e5</span> <span class="number">4883</span>ec10 <span class="number">897</span>dfc8b <span class="number">45f</span>c89c6  UH..H....&#125;..E...</span><br><span class="line"> <span class="number">0010</span> bf000000 <span class="number">00b</span>80000 <span class="number">0000e800</span> <span class="number">000000</span>c9  ................</span><br><span class="line"> <span class="number">0020</span> c3554889 e54883ec <span class="number">10</span>c745f8 <span class="number">01000000</span>  .UH..H....E.....</span><br><span class="line"> <span class="number">0030</span> c745fc02 <span class="number">0000008b</span> <span class="number">15000000</span> <span class="number">008b</span>0500  .E..............</span><br><span class="line"> <span class="number">0040</span> <span class="number">0000008</span>d <span class="number">04020345</span> f80345fc <span class="number">89</span>c7e800  .......E..E.....</span><br><span class="line"> <span class="number">0050</span> <span class="number">0000008b</span> <span class="number">45f</span>8c9c3                    ....E...</span><br><span class="line">Contents of section .data:</span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    T...U...</span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> <span class="number">0000</span> <span class="number">25640</span>a00                             %d..</span><br><span class="line">Contents of section .comment:</span><br><span class="line"> <span class="number">0000</span> <span class="number">00474343</span> <span class="number">3</span>a202847 <span class="number">4e552920</span> <span class="number">342e342</span>e  .GCC: (GNU) <span class="number">4.4</span>.</span><br><span class="line"> <span class="number">0010</span> <span class="number">37203230</span> <span class="number">31323033</span> <span class="number">31332028</span> <span class="number">52656420</span>  <span class="number">7</span> <span class="number">20120313</span> (Red</span><br><span class="line"> <span class="number">0020</span> <span class="number">48617420</span> <span class="number">342e342</span>e <span class="number">372</span>d3138 <span class="number">2900</span>      Hat <span class="number">4.4</span><span class="number">.7</span><span class="number">-18</span>).</span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> <span class="number">0000</span> <span class="number">14000000</span> <span class="number">00000000</span> <span class="number">017</span>a5200 <span class="number">01781001</span>  .........zR..x..</span><br><span class="line"> <span class="number">0010</span> <span class="number">1b</span>0c0708 <span class="number">90010000</span> <span class="number">1</span>c000000 <span class="number">1</span>c000000  ................</span><br><span class="line"> <span class="number">0020</span> <span class="number">00000000</span> <span class="number">21000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  ....!....A....C.</span><br><span class="line"> <span class="number">0030</span> <span class="number">065</span>c0c07 <span class="number">08000000</span> <span class="number">1</span>c000000 <span class="number">3</span>c000000  .\..........&lt;...</span><br><span class="line"> <span class="number">0040</span> <span class="number">00000000</span> <span class="number">37000000</span> <span class="number">00410e10</span> <span class="number">8602430</span>d  ...<span class="number">.7</span>....A....C.</span><br><span class="line"> <span class="number">0050</span> <span class="number">06720</span>c07 <span class="number">08000000</span>                    .r......</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;func1&gt;:</span><br><span class="line">   <span class="number">0</span>:<span class="number">55</span>                   push   %rbp</span><br><span class="line">   <span class="number">1</span>:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">8</span>:<span class="number">89</span> <span class="number">7</span>d fc             mov    %edi,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   b:<span class="number">8b</span> <span class="number">45</span> fc             mov    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">   e:<span class="number">89</span> c6                mov    %eax,%esi</span><br><span class="line">  <span class="number">10</span>:bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x0</span>,%edi</span><br><span class="line">  <span class="number">15</span>:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">1</span>a:e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">1f</span> &lt;func1+<span class="number">0x1f</span>&gt;</span><br><span class="line">  <span class="number">1f</span>:c9                   leaveq</span><br><span class="line">  <span class="number">20</span>:c3                   retq</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000021</span> &lt;main&gt;:</span><br><span class="line">  <span class="number">21</span>:<span class="number">55</span>                   push   %rbp</span><br><span class="line">  <span class="number">22</span>:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</span><br><span class="line">  <span class="number">25</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">29</span>:c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x1</span>,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">30</span>:c7 <span class="number">45</span> fc <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> movl   $<span class="number">0x2</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">37</span>:<span class="number">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%rip),%edx        # <span class="number">3</span>d &lt;main+<span class="number">0x1c</span>&gt;</span><br><span class="line">  <span class="number">3</span>d:<span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">43</span> &lt;main+<span class="number">0x22</span>&gt;</span><br><span class="line">  <span class="number">43</span>:<span class="number">8</span>d <span class="number">04</span> <span class="number">02</span>             lea    (%rdx,%rax,<span class="number">1</span>),%eax</span><br><span class="line">  <span class="number">46</span>:<span class="number">03</span> <span class="number">45</span> f8             add    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">49</span>:<span class="number">03</span> <span class="number">45</span> fc             add    <span class="number">-0x4</span>(%rbp),%eax</span><br><span class="line">  <span class="number">4</span>c:<span class="number">89</span> c7                mov    %eax,%edi</span><br><span class="line">  <span class="number">4</span>e:e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       callq  <span class="number">53</span> &lt;main+<span class="number">0x32</span>&gt;</span><br><span class="line">  <span class="number">53</span>:<span class="number">8b</span> <span class="number">45</span> f8             mov    <span class="number">-0x8</span>(%rbp),%eax</span><br><span class="line">  <span class="number">56</span>:c9                   leaveq</span><br><span class="line">  <span class="number">57</span>:c3                   retq</span><br></pre></td></tr></table></figure><h4 id="3-3-2-数据段和只读数据段"><a href="#3-3-2-数据段和只读数据段" class="headerlink" title="3.3.2 数据段和只读数据段"></a>3.3.2 数据段和只读数据段</h4><ul><li>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量</li><li>.dodata端存放的是只读数据，一般是程序里面的只读变量，如const修饰的变量和</li></ul><h4 id="3-3-3-BSS段"><a href="#3-3-3-BSS段" class="headerlink" title="3.3.3 BSS段"></a>3.3.3 BSS段</h4><p>.bss段存放的是未初始化的全局变量和局部静态变量</p><p>字符串常量</p><h3 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h3><h3 id="3-5-链接的接口–符号"><a href="#3-5-链接的接口–符号" class="headerlink" title="3.5 链接的接口–符号"></a>3.5 链接的接口–符号</h3><h3 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h3><h3 id="3-7-本章小结"><a href="#3-7-本章小结" class="headerlink" title="3.7 本章小结"></a>3.7 本章小结</h3>]]></content>
      
      
      <categories>
          
          <category> 《程序员的自我修养》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）静态链接</title>
      <link href="/2018/08/19/self-contivation-of-programmers-two/"/>
      <url>/2018/08/19/self-contivation-of-programmers-two/</url>
      
        <content type="html"><![CDATA[<h3 id="2-1-被隐藏了的过程"><a href="#2-1-被隐藏了的过程" class="headerlink" title="2.1 被隐藏了的过程"></a>2.1 被隐藏了的过程</h3><p>4个步骤：预处理、编译、汇编、链接</p><h4 id="2-1-1-预编译"><a href="#2-1-1-预编译" class="headerlink" title="2.1.1 预编译"></a>2.1.1 预编译</h4><p><code>gcc -E hello.c -o hello.i</code> 或者 <code>cpp hello.c &gt; hello.i</code></p><p><strong>预编译</strong>过程主要处理那些源代码文件中以#开始的预编译指令，比如#include、#define等主要处理规则如下</p><ul><li>将所有的#define删除，并展开所有宏定义</li><li>处理所有条件编译指令，比如#if #ifdef #elif #else #endif</li><li>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置，这个过程是递归进行的，就是说被包含的文件可能还包含其他文件</li><li>删除所有的注释</li><li>添加行号额文件标识，比如#2 hello.c 2， 以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示的行号</li><li>保留所有的#pragma编译器指令，因为编译器须要使用它们</li></ul><p>经过编译处理后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到i文件中</p><a id="more"></a><h4 id="2-1-2-编译"><a href="#2-1-2-编译" class="headerlink" title="2.1.2 编译"></a>2.1.2 编译</h4><p>编译过程就是把预处理万的文件进行一系列词法分析、语法分析、语义分析及优化后生产响应的汇编代码文件。这个部分是核心部分，也是最复杂的部分之一</p><p><code>gcc -S hello.i -o hello.s</code></p><h4 id="2-1-3-汇编"><a href="#2-1-3-汇编" class="headerlink" title="2.1.3 汇编"></a>2.1.3 汇编</h4><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。<br><code>as hello.s -o hello.o</code></p><h4 id="2-1-4-链接"><a href="#2-1-4-链接" class="headerlink" title="2.1.4 链接"></a>2.1.4 链接</h4><p>将在后面详细讲解，这里不做记录</p><h3 id="2-2-编译器做了什么"><a href="#2-2-编译器做了什么" class="headerlink" title="2.2 编译器做了什么"></a>2.2 编译器做了什么</h3><p>编译器就是将高级语言翻译成机器语言的一个工具。</p><p>使用机器指令或者汇编语言十分费事，开发效率低下，并且依赖于特定的机器，一个为某种CPU编写的程序在另外一个cpu下完全无法进行，要重新编写，所以希望采用自然语言来描述程序。所以就有了FORTRAN和C</p><p>编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化</p><h3 id="2-3-链接器年龄比编译器长"><a href="#2-3-链接器年龄比编译器长" class="headerlink" title="2.3 链接器年龄比编译器长"></a>2.3 链接器年龄比编译器长</h3><p>程序设计的模块化</p><p>最常见的属于静态语言的C、C++模块之间通信有两种方式，一种是模块间的函数调用，另外一种是模块间的变量访问。</p><p>函数访问必须知道目标函数的地址，变量访问也需知道目标变量的地址，所以这两种方式可以归为模块间符号的引用。</p><h3 id="2-4-模块拼装–静态链接"><a href="#2-4-模块拼装–静态链接" class="headerlink" title="2.4 模块拼装–静态链接"></a>2.4 模块拼装–静态链接</h3><p>链接过程包括了地址和空间分配、符号决议、重定位等步骤</p><h3 id="2-5-本章小结"><a href="#2-5-本章小结" class="headerlink" title="2.5 本章小结"></a>2.5 本章小结</h3><p>4个步骤:预编译、编译、汇编、链接</p><p>编译步骤：词法分析、语法分析、语义分析、中间代码生成、目标代码生成与优化</p><p>静态链接的基本概念：重定位、符号、符号决议、目标文件、库、运行库</p>]]></content>
      
      
      <categories>
          
          <category> 《程序员的自我修养》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）程序员的自我修养</title>
      <link href="/2018/08/19/self-contivation-of-progammers-one/"/>
      <url>/2018/08/19/self-contivation-of-progammers-one/</url>
      
        <content type="html"><![CDATA[<h3 id="第1部分-简介"><a href="#第1部分-简介" class="headerlink" title="第1部分 简介"></a>第1部分 简介</h3><h4 id="1-1-从Hello-World说起"><a href="#1-1-从Hello-World说起" class="headerlink" title="1.1 从Hello World说起"></a>1.1 从Hello World说起</h4><h4 id="1-2-万变不离其宗"><a href="#1-2-万变不离其宗" class="headerlink" title="1.2 万变不离其宗"></a>1.2 万变不离其宗</h4><p>对于系统程序开发者来说，计算机多如牛毛的硬件设备中，有三个部件最为关键，他们分别是中央处理器CPU、内存和I/O控制芯片，这三个部件几乎就是计算机的核心</p><p>早期的计算机没有很复杂的图形功能，CPU的核心频率也不高，跟内存的频率一样，他们都是直接连接在同一个<strong>总线</strong>上。</p><p>由于I/O设备诸如显示设备、键盘、软盘和磁盘等速度与CPU和内存相比还是慢很多，当时也没有复杂的图形设备，显示设备大多是只能输出字符的终端，为了协调I/O设备与总线之间的速度，也为了能够让CPU能够和I/O设备进行通信，一般每个设备都会有一个相应的I/O控制器。</p><p>后来由于CPU核心频率的提升，导致内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线，而CPU采用倍频的方式与系统总线进行通信。</p><p>为了协调CPU、内存和高速的图形设备，人们专门设计了一个高速的北桥芯片，以便他们之间能够高速地交换数据。</p><p>由于北桥的运行速度非常高，所有相对低速的设备如果全部连接在北桥上，北桥既需要处理高速设备有需要处理低速设备，设计就会十分复杂，于是设计了专门处理低速设备的南桥芯片。</p><p>磁盘、USB、键盘、鼠标等设备都连接在南桥上，由南桥将它们汇总后连接在北桥上。</p><a id="more"></a><h5 id="SMP与多核"><a href="#SMP与多核" class="headerlink" title="SMP与多核"></a>SMP与多核</h5><p>在过去50年里，CPU的频率从几十kHz到现在的4GHz,整整提高了数十万倍，基本每18个月频率就会翻倍，但是自2004年以来，这种规律几乎已经失效，CPU的频率自从那开始再也再也没有发生质的提高，因为人们在制造CPU的工艺方面已经达到了物理极限。</p><p>在频率上短期内没有提高的余地了，于是通过增加CPU数量来提高速度。<br>对称处理器(SMP symmetrical Muti-Processing)简单的将就是每个CPU在系统中所处的地位和所发挥的功能都是一样的，是互相对称的。</p><h4 id="1-3-站得高，望得远"><a href="#1-3-站得高，望得远" class="headerlink" title="1.3 站得高，望得远"></a>1.3 站得高，望得远</h4><p>系统软件这个概念其实比较模糊，传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块，一块是平台型的，比如操作系统、内核、驱动程序、运行库和数以千计的系统工具。另一块是用于程序开发的，比如编译器、汇编器、链接器等开发工具和开发库。</p><p>计算机科学领域的任何问题都可以通过增加一个间接的中间件来解决<br>Any problem in computer science can be solved by another layer of indirection.</p><table><thead><tr><th>Applications:</th><th>Developments Tools:</th></tr></thead><tbody><tr><td>Web Browser</td><td>Development Libraries</td></tr><tr><td>Video Player</td><td>C/C++ Complier</td></tr><tr><td>Word Processor</td><td>Assember</td></tr><tr><td>Email Client</td><td>Library Tools</td></tr><tr><td>Image Viewer</td><td>Debug Tools</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>每个层次之间都需要互相通信，通信需要有一个通信的协议，我们一般将其称为接口。接口的下面那层是接口的提供者，由它定义接口。接口的上面那层是接口的使用者，它使用该接口来实现所需要的功能。</p><p>除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对他下面那层的包装和扩展，正式这些中间层的存在，使得应用程序和硬件之间保持相对的独立。</p><p>硬件和操作系统本身保持了向后兼容性，所以一些芯片和DOS系统设计的软件在最新的多核处理器下还是能够运行的</p><h4 id="1-4-操作系统做什么"><a href="#1-4-操作系统做什么" class="headerlink" title="1.4 操作系统做什么"></a>1.4 操作系统做什么</h4><p>操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源</p><h5 id="1-4-1-不要让CPU打盹"><a href="#1-4-1-不要让CPU打盹" class="headerlink" title="1.4.1 不要让CPU打盹"></a>1.4.1 不要让CPU打盹</h5><ul><li>多道程序<blockquote><p>如果一个CPU只能运行一个程序那么当程序读写磁盘时，CPU就空闲下来了，于是人们就编写了一个监控程序，当某个程序无需使用CPU时，监控程序就把另外正在等待CPU资源的程序启动，是的CPU能够充分利用其阿里，这种被称为多道程序，大大提高了CPU的利用率。</p></blockquote></li></ul><p>但是这种原始的多道程序技术存在最大的问题是程序之间的调度策略太粗糙，程序之间不分轻重缓急，导致一些紧急的任务不能优先处理。</p><ul><li>分时系统<blockquote><p>经过稍微改进，程序运行模式编程一种协作的模式，即每个程序运行一段时间以后都注重让出CPU给其他程序，是的一段时间内每个程序都有机会运行一小段时间，这种程序协作模式叫做<strong>分时系统</strong></p></blockquote></li></ul><p>如果一个程序在进行一个很耗时的计算，一致霸占着CPU不放，其他系统都只能等着，整个系统看过去就像死机了一样。系统中的任何一个程序死循环都会导致系统死机</p><ul><li><p>多任务系统</p><blockquote><p>操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，所有的应用程序都是以<strong>进程</strong>的方式运行在笔操作系统权限更低的几倍，每个进程都有自己独立的地址空间，使得进行之间的地址空间相互隔离。</p></blockquote></li><li><p>抢占式</p></li></ul><blockquote><p>CPU由操作系统统一进行分配，每一个进程根据进程优先级的高低都会有机会得到CPU，但是如果运行时间超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他正在等待运行的进程，这种CPU的分配方式即为抢占式，操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</p></blockquote><p>如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速得切换，从而造成了很多进程都在同时运行的假象</p><h5 id="1-4-2-设备驱动"><a href="#1-4-2-设备驱动" class="headerlink" title="1.4.2 设备驱动"></a>1.4.2 设备驱动</h5><p>操作系统作为硬件层的上层，它是对硬件的管理和抽象，对于操作系统上面的运行库和应用程序来说，他们希望看到的是一个统一的硬件访问模式。</p><p>当成熟的操作系统出现以后，硬件逐渐被抽象成了一系列概念。繁琐的硬件细节全部交给了操作系统，具体的讲是操作系统中的硬件驱动程序来完成。</p><p>驱动程序可以看做是操作系统的一部分，往往跟操作系统内核一起运行在特权级，但它又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。</p><ul><li>硬盘的结构介绍</li></ul><p>硬盘基本的存储单位为扇区，每一个扇区一般为512字节，一个硬盘往往有多个盘片，每个盘片分两面，没面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。</p><p>如：</p><ul><li>一个硬盘有2个盘片</li><li>每个盘片有65536磁道</li><li>每个磁道分1024个扇区<br>那么硬盘的容量就为 2<em>2</em>65536<em>1024</em>512=137 438 953 472（128G）</li></ul><h4 id="1-5-内存不够怎么办"><a href="#1-5-内存不够怎么办" class="headerlink" title="1.5 内存不够怎么办"></a>1.5 内存不够怎么办</h4><p>进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间很好地共享，从进程的角度看好像是它独占了CPU而不用考虑与其他进程分享CPU的事情</p><p>在早起的计算机中，程序是直接运行在物理内存上的，也就是说，程序在运行时所访问的地址都是物理地址。只要程序要求的内存空间不要超过物理内存的大小就不会有问题，事实上，为了更有效地利用硬件资源，我们必须同时运行多个程序.</p><p>那如何将计算机上有限的物理内存分配给多个程序使用?<br>如果有128M内存，程序A需要20MB，程序B需要100MB，比较直接的做法就是先给A分配20MB内存再给B分配100MB内存，这样两个程序就可以同时运行，但这种策略有很多问题</p><ul><li>地址空间不隔离，数据容易被别的程序篡改</li><li>内存使用率低，如果有程序C进来，要先将B停止写入，C读入内存开始运行，有大量的数据换入换出，效率十分低下</li><li>程序运行的地址不确定。每次程序装入内存时，内存的位置不不确定的。</li></ul><p><strong>虚拟地址：</strong> 解决这个问题的思路就是增加中间层，即使用一种间接的地址访问方法。把程序给出的地址看做是一种虚拟地址Virtual Address，然后通过某周映射方法，将虚拟地址转换成物理地址。只要能控制好这个虚拟地址，就能保证任意一个程序所访问的物理内存区域与另一个程序相互不重叠，达到地址空间隔离效果。</p><h5 id="1-5-1-关于隔离"><a href="#1-5-1-关于隔离" class="headerlink" title="1.5.1 关于隔离"></a>1.5.1 关于隔离</h5><p>作为一个普通的程序，需要的是一个简单的执行环境，有一个单一的地址空间，有自己的CPU。</p><p><strong>地址空间：</strong> 是一个比较抽象的概念，可以想象成是一个很大的数组，每个数组的元素是一个字节，这个数组的大小由地址空间的地址长度决定。</p><p>如32位的地址空间大小为2^32 = 4294967296 字节，即4GB ,地址空间的有效地址就是0~4294967296,用十六进制表示就是0x00000000 ~ 0xFFFFFFFF</p><ul><li>虚拟地址空间<blockquote><p>虚拟的，不存在的，每个进程拥有自己独立的虚拟空间，每个进程只能访问自己的地址空间，这样做到了有效的隔离</p></blockquote></li><li>物理地址空间<blockquote><p>实实在在存在的，存在与计算机中，对于每一台计算机来说只有唯一的一个。</p></blockquote></li></ul><h5 id="1-5-2-分段（Segmentation）"><a href="#1-5-2-分段（Segmentation）" class="headerlink" title="1.5.2 分段（Segmentation）"></a>1.5.2 分段（Segmentation）</h5><p>即通过虚拟空间地址映射物理空间的方法将物理空间分成不同的段分配给不同的程序。当程序访问了不属于自己的地址空间时，就会报警，不允许访问，解决了物理空间隔离和程序地址不稳定的弊端，但是仍不能解决效率低的问题</p><h5 id="1-5-3-分页（Paging）"><a href="#1-5-3-分页（Paging）" class="headerlink" title="1.5.3 分页（Paging）"></a>1.5.3 分页（Paging）</h5><p>分页的基本方法是把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定或硬件支持多种大小的页，有操作系统选择决定页的大小。</p><p>目前几乎所有PC操作系统都使用4kb大小的页</p><p>虚拟空间的页叫做虚拟页</p><p>物理内存中的页叫做物理页</p><p>磁盘中的页叫做磁盘页</p><p>虚拟空间的页被映射到同一个物理页，实现了内存共享</p><p>如果一个进程的虚拟页在磁盘汇总，操作系统会从磁盘中读取出来并且装入内存，然后将内存中的这两个页与虚拟页建立映射关系。</p><p>保护也是页映射的目的之一，每个页可以设置权限属性，谁可以修改，谁可以访问等，而只有操作系统有权限修改这些属性，那么操作系统就可以做到保护自己和保护进程。</p><p>虚拟存储的实现需要依靠硬件的支持，对于不同的CPU来说是不同，但是几乎所有的硬件都采用一个叫Memory Management Unit（MMU）的部件来进行页映射。</p><p>在页映射模式下,CPU发出的是Viryual Address ，经过MMU 转换成 Physical Address。一般MMU集成在CPU内部。</p><h4 id="1-6-众人拾柴火焰高"><a href="#1-6-众人拾柴火焰高" class="headerlink" title="1.6 众人拾柴火焰高"></a>1.6 众人拾柴火焰高</h4><h5 id="1-6-1-线程基础"><a href="#1-6-1-线程基础" class="headerlink" title="1.6.1 线程基础"></a>1.6.1 线程基础</h5><p>多线程：实现软件并发执行的一个重要方法。这一节将回顾线程概念、线程调度、线程安全、用户线程与内核线程之间的映射关系。</p><p><strong>什么是线程：</strong></p><p>线程Thread，有时会被称为<strong>轻量级进程</strong>，是程序执行流的最小单元。</p><p>一个标准的线程由</p><ul><li>线程ID</li><li>当前指令指针PC</li><li>寄存器集合</li><li>堆栈</li></ul><p>组成。</p><p>通常意义上，一个进程有一到多个线程组成，各个线程之间共享程序的内存空间（代码段、数据段、堆等）以及一些进程级的资源（打开文件和信号）</p><p>多个线程可以互相不干扰的并发执行，并共享进程的全局变量和堆的数据。</p><h6 id="使用多线程的原因"><a href="#使用多线程的原因" class="headerlink" title="使用多线程的原因"></a>使用多线程的原因</h6><ul><li>某个操作可能会陷入长时间等待，等待的线程会进入睡眠状态，无法继续执行。多线程可以有效利用等待的时间，典型的例子是等待网络响应</li><li>某个操作会消耗大量的时间，如果只有一个线程，程序和用户之间的交互就会终端。多线程可以让一个线程负责交互，另外一个线程负责计算</li><li>程序逻辑本身就要求并发操作，比如一个多段下载软件件 Bittorent</li><li>多CPU或多核计算机本身具备同事执行多个线程的能力，因此单线程无法发挥出计算出的全部计算能力</li><li>相对于多进程应用，多线程在数据共享方面效率要高很多</li></ul><h5 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h5><p>线程的访问非常自由，可以访问进程内存里的所有数据，实际运用中线程也拥有自己的私有存储空间，包括以下几个方面：</p><ul><li>栈</li><li>线程局部存储</li><li>寄存器（寄存器是执行流的基本数据）</li></ul><p>C程序的角度来看，数据在线程之间是否私有如表所示</p><table><thead><tr><th>线程私有</th><th>线程之间共享（进程所有）</th></tr></thead><tbody><tr><td>局部变量</td><td>全局变量</td></tr><tr><td>函数的参数</td><td>堆上的数据</td></tr><tr><td>TLS数据</td><td>函数里的静态变量</td></tr><tr><td></td><td>程序代码，任何线程都有权利读取并执行任何代码</td></tr><tr><td></td><td>打开的文件，A线程打开的文件可以由B线程读写</td></tr></tbody></table><h5 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h5><p>线程总是并发执行的</p><p>当线程数量小于等于处理器数量时，线程的并发时真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。</p><p>线程数量大于处理器数量的抢矿，线程的并发会受到一些阻碍，因为此时至少有一个处理器会运行多个线程。</p><p>操作系统让线程轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒）,这样每个线程就看起来在同时执行。</p><ul><li>线程调度</li></ul><p>这样一个不断在处理器上切换不同的线程的行为称之为<strong>线程调度</strong></p><p>线程调度中，线程至少有三种状态，分别是:</p><ul><li>运行：此时线程正在执行</li><li>就绪：此时线程可以立刻运行，但CPU已经被占用</li><li><p>等待：此时线程正在等待某一事件（通常是I/O或者同步）发生，无法执行。</p></li><li><p>时间片</p></li></ul><p>处于运行中的线程拥有一段可以执行的时间，这段时间称为<strong>时间片</strong></p><p>当时间片用尽的时候，该线程将进入就绪状态</p><p>如果在时间片用尽之前线程就开始等待某事件，那么它将进入等待状态</p><p>每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续运行</p><p>主流的调度方式都带有 <strong>优先级调度</strong>和<strong>轮转法</strong></p><ul><li>IO密集型线程</li></ul><p>我们一般把频繁等待的线程称之为<strong>IO密集型线程</strong></p><ul><li>CPU密集型线程</li></ul><p>把很少等待的线程成为<strong>CPU密集型线程</strong></p><p>通常情况下，IO密集型线程笔CPU密集型线程要受欢迎的多，IO密集型线程总是比CPU密集型线程容易得到优先级的提升。道理很简单频繁等待的线程通常只占用很少的时间，CPU也喜欢捏软柿子</p><ul><li>饿死现象</li></ul><p>在优先级调度下，存在一种<strong>饿死</strong>的现象，一个线程被饿死，是说它的优先级较低，在它执行之前，总是有高优先级的线程要执行，因此这个低优先级的进程就很可能饿死。</p><p>为了避免饿死现象，调度系统常常会逐步提升哪些等待了过长时间的得不到执行的线程的优先级，这样，只要等待足够长的时间，其优先级一定会提高到足够让它执行的程度。</p><p><strong>优先级调度环境下线程优先级改变的三种方式</strong></p><ul><li>用户指定优先级</li><li>根据进入等待状态的频繁程度提升或者降低优先级</li><li>长时间得不到执行而被提升优先级</li></ul><h5 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h5><ul><li><p>抢占</p><blockquote><p>我们之前的线程调度有一个特点，就是在线程用尽时间片之后会被强制剥夺继续执行的权利，而进入就绪状态，这个过程叫做抢占。</p></blockquote></li><li><p>不可抢占</p><blockquote><p>在早起系统里，线程不不可抢占的，线程必须手动进入就绪状态，而不是依靠时间片用来来强制进入，如果线程始终拒绝进入就绪状态，并且不进行任何的等操作，那么其他线程将永远无法进行。</p></blockquote></li></ul><p>在不可抢占线程中，线程主动放弃执行无非两种情况</p><ul><li>当线程试图等待某件事(I/O等)</li><li>线程主动放弃时间片</li></ul><blockquote><p>因此在不可抢占线程执行的时候，有一个显著的特点，那就是线程调度的时机是确定的，线程调度指挥发生在线程主动放弃指向或者线程等待某件事的时候，这样可以避免一些因为抢占线程里调度时机不确定而产生的问题。</p></blockquote><h5 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h5><p>Windows对线程和进程的实现如同教科书一般的标准，windows内核有明确的线程和进程概念，<strong>但是对于Linux来说，线程并不是一个通用的概念</strong></p><p>Linux对线程的支持颇为贫乏，在Linux内核中并不存在真正意义上的线程概念。</p><p>Linux将所有执行实体（无论是线程还是进程）都成为<strong>任务</strong>，每一个任务的概念都类似于一个单线程的进程。具有内存空间、执行实体、文件资源等。</p><p>Linux下不同的任务之间可以选择共享内存空间，在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。</p><p>Linux下，通过以下方法可以创建一个新的任务</p><table><thead><tr><th>系统调用</th><th>作用</th></tr></thead><tbody><tr><td>fork</td><td>复制但那个钱进程</td></tr><tr><td>exec</td><td>使用新的可执行映像覆盖当前可执行映像</td></tr><tr><td>clone</td><td>创建子进程并从指定位置开始执行</td></tr></tbody></table><h4 id="1-6-2-线程安全"><a href="#1-6-2-线程安全" class="headerlink" title="1.6.2 线程安全"></a>1.6.2 线程安全</h4><p>多线程程序处于一个多变的环境当中，可访问的全局变量和堆数据随时都可能被其他的线程改变，因此多线程程序在并发时数据的一致性变得非常重要。</p><ul><li>竞争与原子操作<br>多个线程同时访问一个共享数据，可能造成很恶劣的后果。</li></ul><p>我们把单指令的操作成为原子的。</p><p>因为无论如何，单条指令的执行是不会被打断的。但是仅仅适用于比较简单特定的场合，在复杂的场合下我们需要更加通用的手段：锁</p><ul><li>同步与锁<br>为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们要将各个线程对同一个数据的访问同步。</li></ul><p>所谓同步，就是在一个线程访问数据为结束的时候其他线程不得对同一个数据进行访问</p><p>同步最常见的方法是使用锁。</p><p>锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁，在锁已经被占用的时候试图获取锁的，线程会等待，直到锁重新可用。</p><p><strong>二元信号量</strong>是最简单的一种锁，它只有两种状态，占用与非占用。</p><p>他适合只能被唯一一线程独占访问的资源。</p><p>对于允许多个线程并发访问的资源，多元信号量简称信号量。</p><p>一个初始值为N的信号量允许N个线程并发访问，线程访问资源的时候首先获取信号量，进行如下操作：</p><ul><li>将信号量减小1</li><li>如果信号量小于0，则进入等待状态，否则继续执行</li></ul><p>访问完资源之后，线程四方信号量，进行如下操作</p><ul><li>将信号量加1</li><li>如果信号量的值小于1，唤醒一个等待的线程</li></ul><p><strong>互斥量：</strong><br><strong>临界区：</strong><br><strong>读写锁：</strong><br><strong>条件变量：</strong></p><ul><li>可重入与线程安全</li><li>过度优化</li><li><h4 id="1-6-3-多线程内部情况"><a href="#1-6-3-多线程内部情况" class="headerlink" title="1.6.3 多线程内部情况"></a>1.6.3 多线程内部情况</h4></li><li>三种线程模型</li><li>一对一模型</li><li>多对一模型</li><li>多对多模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《程序员的自我修养》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reading,C, </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《比特币白皮书》解读</title>
      <link href="/2018/07/22/blockchain-bitcoin/"/>
      <url>/2018/07/22/blockchain-bitcoin/</url>
      
        <content type="html"><![CDATA[<h4 id="白皮书"><a href="#白皮书" class="headerlink" title="白皮书"></a>白皮书</h4><p>今天带来的是中本聪2009年发布的比特币白皮书《Bitcoin: A Peer-to-Peer Electronic Cash System》的个人整理，基本可以明白比特币的基础概念了。<br><img src="https://upload-images.jianshu.io/upload_images/3067941-e1343ac5506242b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="白皮书.png"></p>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
            <tag> BitCoin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）编写智能合约</title>
      <link href="/2018/07/03/coding-solidity/"/>
      <url>/2018/07/03/coding-solidity/</url>
      
        <content type="html"><![CDATA[<p>将使用Solidity编程语言创建一个Dapp用于证明在特定时间的存在、真实性和所有权，即证明一个文件在一个特定时间属于一个特定所有者</p><ul><li>Solidity源文件布局</li><li>理解Solidity的数据类型</li><li>合约的特殊变量和函数</li><li>控制结构</li><li>合约的结构和功能</li><li>编译和部署智能合约</li></ul><h5 id="3-1-Solidity-源文件"><a href="#3-1-Solidity-源文件" class="headerlink" title="3.1 Solidity 源文件"></a>3.1 Solidity 源文件</h5><p>Solidity源文件使用的扩展名为.sol<br>MacOS部署Solidity</p><p><a href="http://wiki.jikexueyuan.com/project/solidity-zh/installing-solidity.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/solidity-zh/installing-solidity.html</a></p><a id="more"></a><h5 id="3-2-智能合约的结构"><a href="#3-2-智能合约的结构" class="headerlink" title="3.2 智能合约的结构"></a>3.2 智能合约的结构</h5><p>合约就像一个类，其中包含：状态变量、函数、函数修改器、事件、结构、枚举</p><p>合约还支持继承，通过在编译时备份代码来实现</p><p>合约同样支持多态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//contract关键字声明一个合约</span><br><span class="line">contract Sample &#123;</span><br><span class="line">    //静态变量</span><br><span class="line">    uint 256 data;//声明data，包含一些数据</span><br><span class="line">    adddress owner;//声明owner 包含所有者的以太坊地址</span><br><span class="line">    </span><br><span class="line">    //定义一个事件，用来通知客户端，一旦data变化，将触发这个事件</span><br><span class="line">    event logData(uint256 dataToLog);</span><br><span class="line">    </span><br><span class="line">    //函数修改器，用于在执行一个函数之前自动检测条件</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        if (msg.sender != owner) throw;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //construtor得到合约构造函数，在部署合约时，调用构造函数。用于初始化状态变量</span><br><span class="line">    function Sample(uint256 initData, address initOwner)</span><br><span class="line">    &#123;</span><br><span class="line">        data = initData;</span><br><span class="line">        owner = initOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //函数</span><br><span class="line">    function getData() returns (uint256 returnedData) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setData(uint256 newData) onlyOwner &#123;</span><br><span class="line">        logData(newData);</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-数据位置"><a href="#3-3-数据位置" class="headerlink" title="3.3 数据位置"></a>3.3 数据位置</h5><p>在Solidity中，根据情况的不同，变量可能不存储在内存和文件系统中。</p><p>对于复杂数据类型，例如字符串、数组和结构类型struct可以向类型中添加storage或者memory进行重写。</p><p>函数参数默认使用memory</p><p>本地变量默认使用storage</p><p>状态变量位置强制使用storage</p><p>数据位置很重要，因为他们会改变分配的行为：</p><ul><li>storage变量和memory变量之间的分配总是创建一个独立的备份。但是如果分配是从memory存储的一种复杂类型到另一种复杂类型，则不创建备份</li><li>到一个状态变量的分配总是创建一个独立的备份</li><li>不能把memeory中存储的复杂类型分配给本地存储变量</li><li>在分配状态变量给本地存储比阿尼量的情况下，本地存储变量指向状态变量，本地存储变量变为指针。</li></ul><h5 id="3-4-什么是不同的数据类型"><a href="#3-4-什么是不同的数据类型" class="headerlink" title="3.4 什么是不同的数据类型"></a>3.4 什么是不同的数据类型</h5><p>Solidity是一种静态类型语言，变量存储的数据类型需要预先定义，所有变量默认值都是0</p><ul><li>布尔值<blockquote><p>最简单的数据类型，可以是true或者false</p></blockquote></li><li>uint8,uint16,uint36…uint256分别用于存储无符号8、16、36位整数，同样还有int8,int16,int36…</li><li>ufixed和fixed代表分数，ufixed0x8,yfixed0x16用于存储未签名的8位、16位分数</li><li>address 用于存储最大20字节的值（16进制表示）用于存储以太坊地址<blockquote><p>address类型有两个属性balance和send。balance用于检测地址余额，send用于向地址发送以太币。send方法拿出需要转账数量的wei，并根据转账是否成功返回true或者false</p></blockquote></li></ul><h6 id="3-4-1-数组类型"><a href="#3-4-1-数组类型" class="headerlink" title="3.4.1 数组类型"></a>3.4.1 数组类型</h6><p>Solidity支持generic和byte两种数组类型，他们支持固定长度和动态长度两种数组，也支持多为数组</p><ul><li><p>generic数组类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract sample &#123;</span><br><span class="line">    //动态长度数组</span><br><span class="line">    int[] myArray = [0, 0];</span><br><span class="line">    function sample(uint index, int value) </span><br><span class="line">    &#123;</span><br><span class="line">        myArray[index] = value;</span><br><span class="line">        </span><br><span class="line">        int[] myArray2 = myArray;</span><br><span class="line">        </span><br><span class="line">        //固定长度数组</span><br><span class="line">        uint24[3] memory myArray3 = [1, 2, 9999];</span><br><span class="line">        </span><br><span class="line">        uint8[2] myArray4 = [1, 2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组有length属性，用户可以给length属性分型一个值，改变数组大小，但不可以在内存中改变数组大小，也不可以改变非动态数组大小</p></li><li>如果想分文动态数组的未设置索引，会抛出异常</li><li>array,structs和map都不可以用作函数参数，也不可以用作函数返回值</li></ul><h6 id="3-4-2-字符串类型"><a href="#3-4-2-字符串类型" class="headerlink" title="3.4.2 字符串类型"></a>3.4.2 字符串类型</h6><p>在Solidity中，有两种方法创建字符串：使用bytes和string，byte用于创建原始字符串，string用于创建UTF-8字符串，字符串长度总是动态的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract sample &#123;</span><br><span class="line">    string myString = &quot;&quot;;</span><br><span class="line">    bytes myRawString;</span><br><span class="line">    </span><br><span class="line">    function sample(string initString, bytes rawStringInit)</span><br><span class="line">    &#123;</span><br><span class="line">        myString = initString;</span><br><span class="line">        string myString2 = myString;</span><br><span class="line">        </span><br><span class="line">        //myString3存储在内存中</span><br><span class="line">        string memory myString3 = &quot;ABCDR&quot;;</span><br><span class="line">        myString3 = &apos;sdsds&apos;;//改变myString3的值</span><br><span class="line">        </span><br><span class="line">        myRawString = rawStringInit;</span><br><span class="line">        myRawString.length++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4-3-结构类型"><a href="#3-4-3-结构类型" class="headerlink" title="3.4.3 结构类型"></a>3.4.3 结构类型</h6><p>Solidity还支持结构类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract sample &#123;</span><br><span class="line">    struct myStruct &#123;</span><br><span class="line">        bool myBool;</span><br><span class="line">        string myString;</span><br><span class="line">    &#125;</span><br><span class="line">    myStruct s1;</span><br><span class="line">    myStruct s2 = myStruct(true, &quot;&quot;);</span><br><span class="line">    </span><br><span class="line">    function sample(bool initBool, string initString)</span><br><span class="line">    &#123;</span><br><span class="line">        s1 = myStruct(initBool, initString);</span><br><span class="line">        myStruct memory = myStruct(initBool, initString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="3-4-4-枚举类型"><a href="#3-4-4-枚举类型" class="headerlink" title="3.4.4 枚举类型"></a>3.4.4 枚举类型</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract sample &#123;</span><br><span class="line">    enum OS &#123;windows, Linux, OSX, UNIX&#125;</span><br><span class="line">    OS choice;</span><br><span class="line">    </span><br><span class="line">    function sample(OS chosen)</span><br><span class="line">    &#123;</span><br><span class="line">        choice = chosen;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function setLinuxOS()</span><br><span class="line">    &#123;</span><br><span class="line">        choice = OS.Linux;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getChoice() returns (OS chosenOS)</span><br><span class="line">    &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-4-5-mapping类型"><a href="#3-4-5-mapping类型" class="headerlink" title="3.4.5 mapping类型"></a>3.4.5 mapping类型</h6><p>mapping数据类型还是一个哈希表。只可以存在storage中，不存在memory中，因为他们是作为状态变量声明的。</p><p>可以认为mapping类型包含key/value对，不是实际存储key，而是存储key的keccak256哈希，用于查询value。</p><p>mapping类型没有长度，不可以分配给另个一个mapping</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contrcat sample &#123;</span><br><span class="line">    mapping (int =&gt; string) myMap;</span><br><span class="line">    function sample(int key, string value)</span><br><span class="line">    &#123;</span><br><span class="line">        myMap[key] = value;</span><br><span class="line">        </span><br><span class="line">        mapping (int =&gt; string) myMap2 = myMap;//myMap2是myMap的映射</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果想访问mapping不存在的key，返回的value为0</span><br></pre></td></tr></table></figure><h6 id="3-4-6-delete操作符"><a href="#3-4-6-delete操作符" class="headerlink" title="3.4.6 delete操作符"></a>3.4.6 delete操作符</h6><p>delete操作符可以用于任何变量，将其设置为默认值0；</p><p>如果对动态数组使用delete操作符，则删除所有元素，长度变为0</p><p>如果对于静态数组使用，则充值所有索引</p><p>对mapping类型使用，不发生任何作用，如果对mao的一个键使用，则会删除该键的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function reset()</span><br><span class="line">&#123;</span><br><span class="line">    delete myArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-控制结构"><a href="#3-5-控制结构" class="headerlink" title="3.5 控制结构"></a>3.5 控制结构</h5><h5 id="3-6-用new操作符创建合约"><a href="#3-6-用new操作符创建合约" class="headerlink" title="3.6 用new操作符创建合约"></a>3.6 用new操作符创建合约</h5><h5 id="3-7-异常"><a href="#3-7-异常" class="headerlink" title="3.7 异常"></a>3.7 异常</h5><h5 id="3-8-外部函数调用"><a href="#3-8-外部函数调用" class="headerlink" title="3.8 外部函数调用"></a>3.8 外部函数调用</h5><h5 id="3-9-合约功能"><a href="#3-9-合约功能" class="headerlink" title="3.9 合约功能"></a>3.9 合约功能</h5><h5 id="3-10-库"><a href="#3-10-库" class="headerlink" title="3.10 库"></a>3.10 库</h5><h5 id="3-11-返回多值"><a href="#3-11-返回多值" class="headerlink" title="3.11 返回多值"></a>3.11 返回多值</h5><h5 id="3-12-导入其他Solidity源文件"><a href="#3-12-导入其他Solidity源文件" class="headerlink" title="3.12 导入其他Solidity源文件"></a>3.12 导入其他Solidity源文件</h5><h5 id="3-13-全局可用变量"><a href="#3-13-全局可用变量" class="headerlink" title="3.13 全局可用变量"></a>3.13 全局可用变量</h5><h5 id="3-14-以太币单位"><a href="#3-14-以太币单位" class="headerlink" title="3.14 以太币单位"></a>3.14 以太币单位</h5><h5 id="3-15-存在、真实性和所有权合约"><a href="#3-15-存在、真实性和所有权合约" class="headerlink" title="3.15 存在、真实性和所有权合约"></a>3.15 存在、真实性和所有权合约</h5><h5 id="3-16-编译和部署合约"><a href="#3-16-编译和部署合约" class="headerlink" title="3.16 编译和部署合约"></a>3.16 编译和部署合约</h5><h5 id="3-17-总结"><a href="#3-17-总结" class="headerlink" title="3.17 总结"></a>3.17 总结</h5>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
          <category> 《区块链项目开发指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初始Kafka</title>
      <link href="/2018/03/19/kafka-easy/"/>
      <url>/2018/03/19/kafka-easy/</url>
      
        <content type="html"><![CDATA[<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性的架构，是大型分布式系统中不可缺少的中间件</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>异步处理</p><pre><code>串行方式：用户注册-&gt;写入数据库-&gt;发送注册邮件-&gt;发送注册短信并行方式：用户注册-&gt;写入数据库-&gt;发送邮件并且发送短信消息队列：用户注册-&gt;写入数据库-&gt;写入消息队列-&gt;发送邮件和短信的消费者异步读取消息队列，写入消息队列即将结果返回给客户端</code></pre><p>流量大的时候redis并不可靠</p><p>应用解耦<br>    用户下单后，订单系统需要通知库存系统</p><pre><code>传统方式：订单系统调用库存系统的接口消息队列：    订单系统：当用户下单后，将订单内容写入消息队列，返回订单下单成功    库存系统：订阅下单的消息，采用拉/推的方式获取下单的信息，库存系统根据下单的信息，进行库存操作</code></pre><p>流量削锋<br>    秒杀活动，因为流量过大，导致流量暴增</p><pre><code>传统方式：突然接受来自前端大量订单请求消息队列：在应用前端加入消息队列用户请求，服务器接收后首先写入消息队列，超过最大数量，直接抛弃用户请求或者跳转到错误页面，秒杀业务根据消息队列的信息进行相关处理</code></pre><p>日志处理</p><pre><code>解决大量日志传输的问题日志采集客户端负责日志数据采集写入KafkaKafka消息队列负责日志数据的接受、存储和转发日志处理应用：订阅并消费Kafka队列中的日志数据</code></pre><p>生产环境中，使用较多的消息队列有ActiveMQ、RabbitMQ、Kafka、RocketMQ</p><a id="more"></a> <h4 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h4><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，可以处理消费者规模较大的网站中的所有动作流数据</p><p>kafka.apache.org</p><p>优势：<br>在普通的硬件上也支持每秒数百万的消息</p><p>支持Kafka服务器和消费机集群来区分消息</p><p>关键概念</p><p>Broker:kafka集群中的一台或者多台服务器统称为broker</p><p>Topic：kafka处理的消息源的不同的分类</p><p>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列，partition中的每个消息都会被分配一个有序的id</p><p>Message：消息，通信的基本单位，每个producer可以向一个topic发布一些消息</p><p>Producers：消息和数据生产者，向kafka的一个topic发布消息的过程叫做producers</p><p>Consumers：消息和数据消费者，订阅topic并处理其发布的消息的过程叫做consumers</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装JAVA环境安装JDK<br>：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/jdk</span><br><span class="line">cp jdk.gz /usr/jdk</span><br><span class="line">tar -xzvf jdk.gz</span><br><span class="line">vim /etc/profile</span><br><span class="line">#添加一下内容</span><br><span class="line">JAVA_HOME=/usr/jdk</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></table></figure><p><code>source /etc/profile</code></p><p>安装kafka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#启动zookeeper server</span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</span><br><span class="line">#启动kafka</span><br><span class="line">bin/kafka-server-start.sh config/server.properties &amp;</span><br><span class="line">#producer</span><br><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line">#consumer</span><br><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic zhyunfe --from-beginning</span><br></pre></td></tr></table></figure></p><h4 id="结合PHP使用"><a href="#结合PHP使用" class="headerlink" title="结合PHP使用"></a>结合PHP使用</h4><p>安装php扩展<br>需要打一个库librdkafka:<a href="https://github.com/edenhill/librdkafka.git" target="_blank" rel="noopener">https://github.com/edenhill/librdkafka.git</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/edenhill/librdkafka.git</span><br><span class="line"></span><br><span class="line">tar zxvf librdkafka</span><br><span class="line">cd librdkafka</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>php-rdkafka：<a href="https://github.com/arnaud-lb/php-rdkafka" target="_blank" rel="noopener">https://github.com/arnaud-lb/php-rdkafka</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arnaud-lb/php-rdkafka</span><br><span class="line"></span><br><span class="line">tar -zxvf php-rdkafka</span><br><span class="line">cd php-rdkafka</span><br><span class="line">phpize</span><br><span class="line">./configure --with-php-confif=/usr/local/Cellar/php/lib/php-config</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">#编辑php.ini</span><br><span class="line">vim /usr/local/etc/php/7.0/php.ini</span><br><span class="line">extension=rdkafka.so</span><br><span class="line">重启php</span><br></pre></td></tr></table></figure></p><p>使用kafka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm.</span><br><span class="line"> * User: zhyunfe</span><br><span class="line"> * Date: 2017/12/10</span><br><span class="line"> * Time: 下午9:15</span><br><span class="line"> */</span><br><span class="line">namespace app\index\model;</span><br><span class="line">use think\image\Exception;</span><br><span class="line">class Kafka</span><br><span class="line">&#123;</span><br><span class="line">    public $broker_list = &apos;192.168.37.140:9092&apos;;</span><br><span class="line">    public $topic = &quot;topic&quot;;</span><br><span class="line">    public $partition = 0;</span><br><span class="line">    public $logFile = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    protected  $producer = null;</span><br><span class="line">    protected $consumer = null;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        if (empty($this-&gt;broker_list)) &#123;</span><br><span class="line">            throw new Exception(&apos;broker list not init&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        $rk = new \RdKafka\Producer();</span><br><span class="line">        if (empty($rk)) &#123;</span><br><span class="line">            throw  new Exception(&apos;rdkafka not iniit&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $rk-&gt;setLogLevel(LOG_DEBUG);</span><br><span class="line">        if (!$rk-&gt;addBrokers($this-&gt;broker_list)) &#123;</span><br><span class="line">            throw new Exception(&apos;broker_list not init&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $this-&gt;producer = $rk;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public function send($message = [])</span><br><span class="line">    &#123;</span><br><span class="line">        $topic = $this-&gt;producer-&gt;newTopic($this-&gt;topic);</span><br><span class="line">        var_dump($topic);die();</span><br><span class="line">        return $topic-&gt;produce(RD_KAFKA_PARTITION_UA,$this-&gt;partition,json_encode($message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> KeepLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识ElasticSearch</title>
      <link href="/2018/03/08/skills-es/"/>
      <url>/2018/03/08/skills-es/</url>
      
        <content type="html"><![CDATA[<h4 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h4><ul><li>结构化数据</li></ul><p><strong>概念</strong></p><blockquote><p>行数据，存储在数据库里，可以使用二维表结构来逻辑表达实现的数据，能够用数据或者统一的结构加以表示<br>数字、符号</p></blockquote><ul><li>非结构化数据</li></ul><blockquote><p>无法使用数字或者统一的结构表示</p></blockquote><blockquote><p>文本、图像、声音、网页</p></blockquote><blockquote><p>结构化数据属于非结构化数据</p></blockquote><blockquote><p>非结构化数据即为全文数据</p></blockquote><h4 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h4><blockquote><p>一种将文件中或者数据库中所有文本与检索匹配的文字资料检索的方法称之为全文检索</p></blockquote><h5 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h5><ul><li><p>顺序扫描法</p><blockquote><p>将数据表中所有数据进行挨个扫描，然后对每一个扫描的内容进行逐字扫描，非常慢</p></blockquote></li><li><p>索引扫描法</p><blockquote><p>全文检索的基本思路，即将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的</p></blockquote></li></ul><h4 id="全文检索过程"><a href="#全文检索过程" class="headerlink" title="全文检索过程"></a>全文检索过程</h4><p><strong>两个过程</strong></p><ul><li>索引创建<blockquote><p>索引创建只会创建一次。索引保存了什么？————索引就是一个字典</p></blockquote></li></ul><blockquote><p>第一步：将一些索引的源文档拿出</p></blockquote><blockquote><p>第二步：将源文档传递给分词组件，将内容<strong>拆分成一个个单词</strong>，<strong>去掉标点符号</strong>，<strong>去掉停词</strong></p></blockquote><blockquote><p>第三步：将得到的词元传给语言处理组件，<strong>变成小写</strong>，<strong>将单词缩减为词根形式</strong>，<strong>将单词转换为词根形式</strong></p></blockquote><blockquote><p>第四步：将得到的词传递给索引组件，利用得到的词创建一个词典，对词典安字母顺序进行排序，合并相同的词组合成一个链表</p></blockquote><a id="more"></a><ul><li>搜索索引<blockquote><p>第一步：输入查询语句</p></blockquote></li></ul><blockquote><p>第二步：对查询语句进行词法分析，语法分析及语言处理</p></blockquote><blockquote><p>第三步：搜索索引，得到符合文档</p></blockquote><h4 id="全文检索引擎"><a href="#全文检索引擎" class="headerlink" title="全文检索引擎"></a>全文检索引擎</h4><p>全文检索引擎是目前广泛应用的主流搜索引擎。</p><p>它的工作原理是计算机所以呢程序通过扫描文章中的每一个次，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式</p><h4 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h4><p>ElasticSearch是一个基于Apache Lucene的开源搜索引擎，无论在开源领域还是专有领域，Lucene可以被认为迄今为止最先进，性能最好的、功能最全的搜索引擎库</p><p><strong>优势：</strong></p><ul><li>ES也是使用JAVA开发并使用Lucece作为其核心来实现所有索引和搜索功能，但是它的目的是通过简单的RESRful API来隐藏Lucene的复杂性，从而让全文检索变得简单</li><li>分布式的实时文件存储，每个字段都被索引可被搜索</li><li>分布式的实时分析搜索引擎</li><li>可扩展到上百台服务器，处理PB级结构化或非结构化数据</li><li>所有功能集成在一个服务里面，可以通过RESTful API,各种语言客户端甚至命令行与之监护</li><li>上手容易，提供了很多合理的缺省值，开箱机用，学习成本低</li><li>免费下载、使用和修改</li><li>配置灵活</li></ul><p><strong>官网：</strong></p><p><a href="https://www.elastic.co/" target="_blank" rel="noopener">https://www.elastic.co/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Warning:require(): open_basedir restriction in effect. File</title>
      <link href="/2018/01/20/trouble-open-basedir/"/>
      <url>/2018/01/20/trouble-open-basedir/</url>
      
        <content type="html"><![CDATA[<p>【问题描述】</p><blockquote><p>使用lnmp新建一个项目的时候，引入上级文件报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: require(): open_basedir restriction in effect. File(/home/wwwroot/my.cmf.com/simplewind/thinkphp/base.php) is not within the allowed path(s): (/home/wwwroot/my.cmf.com/public/:/tmp/:/proc/) in /home/wwwroot/my.cmf.com/public/index.php on line 39</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>大体意思就是open_basedir生效中，没有权限访问当前路径<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">open_basedir</span><br><span class="line"><span class="meta">#</span>限制可以访问的路径</span><br><span class="line"><span class="meta">#</span>可以在php.ini里设置，也可以在nginx下设置</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在文件fastcgi.conf中有</span><br><span class="line">fastcgi_param PHP_ADMIN_VALUE "open_basedir=$document_root/:/tmp/:/proc/";</span><br><span class="line"></span><br><span class="line">限制了不能引入上一级的文件</span><br></pre></td></tr></table></figure></p><p>关于open_basedir的描述在这个博客里有讲到<br><a href="https://www.iamle.com/archives/1854.html" target="_blank" rel="noopener">https://www.iamle.com/archives/1854.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 常见错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis安全性简介</title>
      <link href="/2018/01/17/skills-redis-safe/"/>
      <url>/2018/01/17/skills-redis-safe/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis安全性"><a href="#Redis安全性" class="headerlink" title="Redis安全性"></a>Redis安全性</h3><h4 id="常规安全模式"><a href="#常规安全模式" class="headerlink" title="常规安全模式"></a>常规安全模式</h4><p>Redis被设计成仅有可信环境下的可信用户才可以访问</p><h4 id="网路安全"><a href="#网路安全" class="headerlink" title="网路安全"></a>网路安全</h4><p>仅可信的网络用户才可以访问Redis端口</p><p><code>redis.conf</code> 修改  <code>bind 127.0.0.1</code></p><h4 id="认证的特性"><a href="#认证的特性" class="headerlink" title="认证的特性"></a>认证的特性</h4><p>Redis没有尝试去实现访问控制，提供了一个轻量级的认证方式，可以编辑redis.conf文件来启用</p><p>认证授权方式启用后，Redis会拒绝来自没有认证的用户的任何查询</p><p>密码是明文配置在<code>redis.conf</code>文件中的</p><p>Redis并不支持加密，需要实现新增的保护层，例如SSL代理</p><h4 id="禁用特殊命令"><a href="#禁用特殊命令" class="headerlink" title="禁用特殊命令"></a>禁用特殊命令</h4><p>在Redis可以禁用命令或者将他们重命名成难以推测的名称，这样普通用户就只能使用部分命令了</p><p>在<code>redis.conf</code>中 </p><p><code>rename-command CONFIG basdadjdh23234j</code><br>或者删除这个命令<br><code>rename-command CONFIG &#39;&#39;</code></p><h4 id="外部客户端通过仔细构造的输入触发的攻击"><a href="#外部客户端通过仔细构造的输入触发的攻击" class="headerlink" title="外部客户端通过仔细构造的输入触发的攻击"></a>外部客户端通过仔细构造的输入触发的攻击</h4><p>一个攻击者可以通过提交表单提交大量一样的字符串到哈希表里，是的O(1)的算法复杂度(平均时间)达到最差的O(N)，Redis将需要更多的CPU来处理，到最后会导致无法提供服务</p><p>为了防止这类特殊的攻击，redis的哈希函数使用per-excution的伪随机种子</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis持久化简介</title>
      <link href="/2018/01/11/skills-redis-persistence/"/>
      <url>/2018/01/11/skills-redis-persistence/</url>
      
        <content type="html"><![CDATA[<h3 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB Redis DataBase"></a>RDB Redis DataBase</h3><p>可以在指定的时间间隔内生成数据及的时间点快照</p><ul><li><p>是一个非常紧凑的文件，保存了Redis在某个时间点上的数据集，适用于进行备份。</p></li><li><p>非常适用于灾难恢复：只有一个文件，并且内容非常紧凑，可以在加密后将它传送到别的数据中心</p></li><li>可以最大化Redis性能：服进行在保存RDB文件唯一要做的就是fork一个子进程，然后子进程就会处理接下来所有的保存工作，服进行无须执行任何磁盘I/O操作</li><li>在恢复大数据集时笔AOF速度要快</li><li>发生错误时，会有几分钟的数据丢失</li><li>每次保存RDB时都需要fork子进程，数据量大时，会非常耗时，如果CPU时间紧张，就会停止处理客户端</li></ul><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF Append Only File"></a>AOF Append Only File</h3><p>记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集</p><p>AOF文件中的命令全部以Redis协议的格式保存，新命令会被追加到文件的末尾</p><p>Redis还可以在后台对AOF文件进行重写，使得AOF文件的提及不会超出保存数据集状态所需的实际大小</p><ul><li>会让Redis变得非常耐久：可以设置不同的fsync策略，默认每秒fsync一次</li><li>AOF文件是一个只进行追加操作的日志文件，对AOF文件写入不需要进行seek</li><li>Redis</li></ul><blockquote><p>可以同时使用AOF持久化和RDB持久化，在Redis重启时，会优先使用AOF文件来还原数据集，因为AOF保存的数据集通常比RDB文件更加完整</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux设置VIP</title>
      <link href="/2018/01/09/skills-nginx-vip/"/>
      <url>/2018/01/09/skills-nginx-vip/</url>
      
        <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在使用VMVare时，因为mac的ip经常会改变，每次重启虚拟机的时候IP也会改变，所有就要去改host去访问虚拟机中的项目，很麻烦，其实可以固定虚拟机的ip，及时宿主机ip变了也不会改变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"></span><br><span class="line">vim /Library/Preferences/VMware\Fusion/vmnet8/dhcpd.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> Configuration file for ISC 2.0 vmnet-dhcpd operating on vmnet8.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> This file was automatically generated by the VMware configuration program.</span><br><span class="line"><span class="meta">#</span> See Instructions below if you want to modify it.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> We set domain-name-servers to make some DHCP clients happy</span><br><span class="line"><span class="meta">#</span> (dhclient as configured in SuSE, TurboLinux, etc.).</span><br><span class="line"><span class="meta">#</span> We also supply a domain name to make pump (Red Hat 6.x) happy.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>##### VMNET DHCP Configuration. Start of "DO NOT MODIFY SECTION" #####</span><br><span class="line"><span class="meta">#</span> Modification Instructions: This section of the configuration file contains</span><br><span class="line"><span class="meta">#</span> information generated by the configuration program. Do not modify this</span><br><span class="line"><span class="meta">#</span> section.</span><br><span class="line"><span class="meta">#</span> You are free to modify everything else. Also, this section must start </span><br><span class="line"><span class="meta">#</span> on a new line </span><br><span class="line"><span class="meta">#</span> This file will get backed up with a different name in the same directory </span><br><span class="line"><span class="meta">#</span> if this section is edited and you try to configure DHCP again.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Written at: 11/08/2017 23:14:55</span><br><span class="line">allow unknown-clients;</span><br><span class="line">default-lease-time 1800;                # default is 30 minutes</span><br><span class="line">max-lease-time 7200;                    # default is 2 hours</span><br><span class="line"></span><br><span class="line">subnet 192.168.37.0 netmask 255.255.255.0 &#123;</span><br><span class="line">  range 192.168.37.128 192.168.37.254;</span><br><span class="line">  option broadcast-address 192.168.37.255;</span><br><span class="line">  option domain-name-servers 192.168.37.2;</span><br><span class="line">  option domain-name localdomain;</span><br><span class="line">  default-lease-time 1800;                # default is 30 minutes</span><br><span class="line">  max-lease-time 7200;                    # default is 2 hours</span><br><span class="line">  option netbios-name-servers 192.168.37.2;</span><br><span class="line">  option routers 192.168.37.2;</span><br><span class="line">&#125;</span><br><span class="line">host vmnet8 &#123;</span><br><span class="line">  hardware ethernet 00:50:56:C0:00:08;</span><br><span class="line">  fixed-address 192.168.37.1;</span><br><span class="line">  option domain-name-servers 0.0.0.0;</span><br><span class="line">  option domain-name ""; </span><br><span class="line">  option routers 0.0.0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在这里添加你的虚拟机的固定ip</span><br><span class="line">host 你的虚拟机的名字 &#123;</span><br><span class="line">    hardware ethernet 00:50:56:C0:00:08;</span><br><span class="line">     fixed-address 192.168.37.88;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span>    hardware ethernet查看上面配置</span><br><span class="line"><span class="meta">#</span> fixed-address 你要配置的固定ip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Linux </tag>
            
            <tag> Virtual IP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL慢查询</title>
      <link href="/2018/01/08/skills-mysql-slow-query/"/>
      <url>/2018/01/08/skills-mysql-slow-query/</url>
      
        <content type="html"><![CDATA[<p>MySQL 慢查询的相关参数解释：</p><p>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。</p><p>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p><p>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p><p>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</p><p>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p><pre><code>//查看是否开启慢查询，默认为OFFmysql&gt; show variables  like &apos;%slow_query_log%&apos;;//开启慢查询(仅对当前一次有效，重启后就失效了)mysql&gt; set global slow_query_log = 1;//修改慢查询记录触发时间为4秒，默认为10秒mysql&gt; set global long_query_time = 4;//修改my.cnf文件修改参数永久有效在my.cnf文件里增加//开启慢查询slow_query_log =1//指定慢查询日志文件slow_query_log_file=/tmp/mysql_slow.log//设置慢查询记录时间long_query_time = 4系统变量log-queries-not-using-indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。如果调优的话，建议开启这个选项。另外，开启了这个参数，其实使用full index scan的sql也会被记录到慢查询日志。set global log_queries_not_using_indexes=1;慢查询日志分析工具mysqldumpslow 日志文件路径mysqldumpslow /usr/local/var/mysql/Demoer-slow.log</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx 504解决方案</title>
      <link href="/2018/01/06/skills-nginx-504/"/>
      <url>/2018/01/06/skills-nginx-504/</url>
      
        <content type="html"><![CDATA[<p>修改nginx.conf文件</p><p>在http{    </p><pre><code>#添加如下配置</code></pre><p>}</p><pre><code>gzip ongzip_min_length  1k;gzip_buffers     4 128k;gzip_http_version 1.1;gzip_comp_level 2;gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml application/xml+rss;gzip_vary on;gzip_proxied   expired no-cache no-store private auth;gzip_disable   &quot;MSIE [1-6]\.&quot;;fastcgi_connect_timeout 300s;fastcgi_send_timeout 300s;fastcgi_read_timeout 300s;fastcgi_buffer_size 128k;fastcgi_buffers 8 128k;#8 128fastcgi_busy_buffers_size 256k;fastcgi_temp_file_write_size 256k;fastcgi_intercept_errors on;</code></pre><p>修改php-fpm.conf</p><p><a href="http://blog.csdn.net/senlin1202/article/details/50800194" target="_blank" rel="noopener">http://blog.csdn.net/senlin1202/article/details/50800194</a></p><p>如果你的服务器性能足够好，且宽带资源足够充足，PHP脚本没有系循环或BUG的话你可以直接将”request_terminate_timeout”设 置成0s。</p><p>0s的含义是让PHP-CGI一直执行下去而没有时间限制。</p><p>而如果你做不到这一点，也就是说你的PHP-CGI可能出现某个BUG，或者你的宽 带不够充足或者其他的原因导致你的PHP-CGI能够假死那么就建议你给”request_terminate_timeout”赋一个值，这个值可以根 据你服务器的性能进行设定。一般来说性能越好你可以设置越高，20分钟-30分钟都可以。由于我的服务器PHP脚本需要长时间运行，有的可能会超过10分 钟因此我设置了900秒，这样不会导致PHP-CGI死掉而出现502 Bad gateway这个错误。</p><p>而”max_children” 这个值又是怎么计算出来的呢？这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。</p><p>设置”max_children” 也需要根据服务器的性能进行设定，一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右，因此我的”max_children”我 设置成40个，20M*40=800M也就是说在峰值的时候所有PHP-CGI所耗内存在800M以内，低于我的有效内存1Gb。而如果我 的”max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。如果长时间没有得到处 理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。</p><p>max_requests即是说每个进程若超过这个数目(跟php进程有一点点关系,关 系不大),就自动杀死..我这里应该设置512的,不过懒得压力测试了,设置大一点,不过也不要设置过大,是个结构体,没测试过,接近8K到9K大小.网 上动辄设置100k,有点浪费内存了.一个进程浪费大小接近1M.按照网上常用配置的128个进程,大概浪费100M左右.好吧,我承认100M是白菜 价,但也别这样浪费..= =</p><p>max_children基本就是进程数,跟nginx的进程没有想象中的那么大,因为FPM会自己管理进程(有待考证,起码我简单浏览了一下源码,认为是这个意思).参数不宜设置过大,很占内存,进程的消耗就不用我多说了.</p><p>max_children较好的设置方式根据req/s来设置,若程序是 100 req/s的处理能力..最大并发是10K,那么就设置 100比较好,这是动态来调整的.</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql Explain使用详解</title>
      <link href="/2018/01/01/skills-mysql-explain/"/>
      <url>/2018/01/01/skills-mysql-explain/</url>
      
        <content type="html"><![CDATA[<p>Mysql Explain 是常用分析mysql性能的工具，下面简单说一下各参数的分析</p><pre><code>1）id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。2）select_type列常见的有：    A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个    B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个    C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union    D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响    E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null    F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery    G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响    H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select3）table显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的&lt;derived N&gt;就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&lt;union M,N&gt;，与&lt;derived N&gt;类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</code></pre><a id="more"></a>    <pre><code>4）type依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引    A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index    B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描    C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref    D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。    E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引    F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。    G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值    H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。    I：range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。    J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range    K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。    L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。5）possible_keys查询可能使用到的索引都会在这里列出来6）key查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。7）key_len用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。8）ref如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func9）rows这里是执行计划中估算的扫描行数，不是精确值10）extra这个列可以显示的信息非常多，有几十种，常用的有    A：distinct：在select部分使用了distinc关键字    B：no tables used：不带from字句的查询或者From dual查询    C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。    D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中    E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。    F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。    G：using sort_union，using_union，using intersect，using sort_intersection：    using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集    using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集    using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。    H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。    I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition    J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个    K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个    除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息11）filtered    使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）去中心化应用</title>
      <link href="/2017/12/19/blockchain-develop-dapp-desc/"/>
      <url>/2017/12/19/blockchain-develop-dapp-desc/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>如何学习以太坊？ -&gt; 从以太坊的白皮书和黄皮书开始/Building Blockchain Projects</p><p>通过有趣的现实世界案例，将了解到如何编写完全按照程序运行、没有欺诈、没有中心机构或者第三方干预的智能合约，并学习如何创建端到端的区块链应用。</p><p>将介绍加密货币中的密码学、以太币安全、挖矿、智能合约和Solidity等概念</p><p>实例代码下载地址：<a href="http://www.packtpub.com" target="_blank" rel="noopener">http://www.packtpub.com</a></p><p>​                <a href="http://www.hzbook.com" target="_blank" rel="noopener">http://www.hzbook.com</a></p><h3 id="第一章-去中心化应用"><a href="#第一章-去中心化应用" class="headerlink" title="第一章 去中心化应用"></a>第一章 去中心化应用</h3><h5 id="1-1-什么是Dapp"><a href="#1-1-什么是Dapp" class="headerlink" title="1.1 什么是Dapp"></a>1.1 什么是Dapp</h5><p>目前几乎所有互联网应用都是中心化，每个应用的服务端由一个特定的企业或者个人所有，开发者在开发中心化应用，用户也一直在使用中心化应用。</p><p>但是中心化应用存在一些问题：不透明、单点故障、不能防止网络审查。几乎不可能创建某些特定类型的应用</p><p>为了解决这一问题，去中心化应用诞生了，它创建以网络为基础的去中心化应用Dapp</p><a id="more"></a><p>Dapp是一种互联网应用，其后端在去中心化的点对点的网络上运行，且源代码是开源的，网络中不存在能够完全控制的Dapp节点</p><p>不同的Dapp使用不同的数据接口来存储应用数据，比特币Dapp使用区块链数据接口</p><ul><li>一致性协议。Dapp中没有一个中心服务器来协调节点或者决定什么是对的什么是错的，一致性协议可用于解决这个问题（concensus protocol），不同的Dapp通常使用不同额数据结构类型的共识协议，比特币使用   <strong>工作量证明协议（PoW</strong>来达成共识</li></ul><p>为了让用户使用Dapp，每个Dapp都需要一个客户端，使用时，用户首先要运行Dapp中自己的节点服务端，然后将客户端连接至节点服务器。</p><p>Dapp的节点只是提供API，并允许开发者社区使用API开发多种客户端</p><p>建立客户端架构比较麻烦，因此客户端通常作为服务或节点形式出现</p><ul><li><p>Dapp的优点</p><ul><li>Dapp能容错，没有单点故障，默认分布式</li><li>防止某单一机构的干扰</li><li>用户容易相信该应用</li></ul></li><li><p>Dapp的缺点</p><ul><li>修改bug或者更新Dapp很困男，因为网络中每一个节点都需要更新其节点软件</li><li>一些应用要求验证用户身份（KYC），却没有中心化的机构来验证用户身份，开发时会遇到问题</li><li>创建去中心化应用比较困难，因为他们应用复杂的协议达成共识，并且必须从最開是就自行创建并扩大规模，所以不能仅仅实现一个想法，然后不断添加功能</li><li>应用通常独立于第三方API，以获取或者存储数据。Dapp不能依赖中心化应用的API，但是可以依赖其他Dapp，目前Dapp生态圈不大，所以创建起来比较困难，在实践中紧密融合Dapp也比较困难</li></ul></li></ul><h5 id="1-2-去中心化自治组织"><a href="#1-2-去中心化自治组织" class="headerlink" title="1.2 去中心化自治组织"></a>1.2 去中心化自治组织</h5><p>Decentralized Autononmous Organization (DAO) 由计算机程序代表的组织（即组织根据程序中写明的规则运行），完全透明、完全由股东控制，不受政府影响。</p><p>为了达到这个目标，需要把DAO作为DApp来开发，可以说DAO是Dapp的一个子类</p><h5 id="1-3-Dapp中的用户身份"><a href="#1-3-Dapp中的用户身份" class="headerlink" title="1.3 Dapp中的用户身份"></a>1.3 Dapp中的用户身份</h5><p>Dapp主要优点是它一般能保证用户的匿名性，但是许多应用要求用户必须经过身份验证才能使用，因为Dapp没有中央机构，验证身份是一项挑战</p><p>KYC Know Your Customer</p><p>Dapp不能理解和验证扫描文档，也不能发送短信，因此需要用户提供哪些他们可以理解和验证的数字标识，问题是几乎没有Dapp有数字标识，用户也不知道如何得到数字身份</p><p>数字身份有多种形式，目前最受推崇最热门的形式是数字证书（一个用来证明公钥所有权的电子文档）</p><p>基本上一个用户拥有私钥、公钥和数字证书</p><p>数字证书由用户可以信任的授权机构颁发</p><p>目前可供选择的方案：由提供客户端的公司派人手动验证用户身份，比如创建一个比特币账户不需要验证身份，但是当提现的时候交易所去验证</p><p>在应用中验证身份的想法是使一些用户在进行一些欺诈行为之后难以逃脱，让用户难以伪装成其他人，并收集足够的数据跟踪用户，证明该用户进行了一些欺诈行为</p><h5 id="1-4-Dapp中的用户账户"><a href="#1-4-Dapp中的用户账户" class="headerlink" title="1.4 Dapp中的用户账户"></a>1.4 Dapp中的用户账户</h5><p>有多种实现方式，现在最热门的是公钥-私钥来代表一个账户。公钥的哈希是账户的唯一身份，为了改变账户中的数据，用户需要私钥签名</p><h5 id="1-5-访问中心化应用"><a href="#1-5-访问中心化应用" class="headerlink" title="1.5 访问中心化应用"></a>1.5 访问中心化应用</h5><p>Dapp不能依赖于中心化应用，原因是存在单点故障，但是在一些情况下Dapp需要从中心化应用中抓取数据，但是主要问题是Dapp如何知道一个域名中抓取的数据有没有被中间人篡改，数据是否还是真实的响应。</p><p>根据Dapp架构的不同，解决办法也有所不同，在以太坊中，智能合约不能直接发出HTTP请求，为了访问中心化API，可以使用Oraclize服务作为中间人，Oraclize为从中心化服务智能合约中的数据提供TLSNotart验证</p><h4 id="1-6-Dapp中的内部货币"><a href="#1-6-Dapp中的内部货币" class="headerlink" title="1.6 Dapp中的内部货币"></a>1.6 Dapp中的内部货币</h4><p>中心化应用的所有者需要有盈利才能长期维护应用的运行，Dapp虽然没有所有者，但是和中心化应用一样，Dapp节点需要硬件和网路资源才能维持运行。</p><p>Dapp节点需要一些有用的回报来维持运行，于是内部货币登场了，大多数Dapp都有内置内部货币。</p><p>共识协议决定节点收取多少的内部货币。</p><p>根据共识协议，只有为维护Dapp安全和运行做出贡献的哪些特定节点可以赚取货币，只进行数据读取的节点没有回报，也就是指挖矿。</p><ul><li>Dapp内部货币的缺点</li></ul><p>Dapp不能再免费使用了，免费是中心化应用占上风的原因之，因为中心化应用可以通过广告赚钱，为第三方应用提供优质API，所以可以对用户免费。在Dapp中不能加入广告，因为没有人去检查广告尺度，客户端还可能不展示广告，因为展示广告对他们没有好处。</p><h5 id="1-7-什么是授权Dapp"><a href="#1-7-什么是授权Dapp" class="headerlink" title="1.7 什么是授权Dapp"></a>1.7 什么是授权Dapp</h5><p>授权的Dapp并不对所有人开放。授权的Dapp继承了面权限Dapp的全部属性，但是需要权限才能参与到网络中去。授权的Dppp与免权限的Dapp的共识协议是不同的，授权的Dapp没有内部货币。</p><h5 id="1-8-热门的Dapp"><a href="#1-8-热门的Dapp" class="headerlink" title="1.8 热门的Dapp"></a>1.8 热门的Dapp</h5><ul><li>比特币</li></ul><p><strong>账本：</strong> 本质上是一个交易列表。数据库与账本不同，在账本中我们只能添加新的交易；在数据库中我们可以CURD，数据库可以用来实现账本。<br><strong>区块链：</strong> 是用于创建区中心化账本的数据结构，区块链中的区块按序号排列。区块包含一系列的交易、前一个区块的哈希、时间戳、区块回报、区块序号等。</p><p>每一个区块包含前一个区块的哈希，由此创建了区块彼此相连的链，网络中的每一个节点都保留区块链的一个备份</p><p><strong>工作量证明和权益证明等是用于保障区块链安全性的多种共识协议</strong></p><p>在工作量证明中，通过挖矿创建区块，这让区块链保持安全。<br>在工作量证明协议中，挖矿涉及解决复杂问题。</p><p><strong>为什么使用比特币：可以在世界上任何地方快速便捷地发送和接收支付、比特币交易费低于在线支付交易费。黑客可以从商户哪里窃取支付信息，但是在比特币情况下，窃取了比特币的地址是完全没用的，必须使用相关私钥签名</strong></p><ul><li>以太坊<br>是一个去中心化平台，可以在其上运行使用智能合约编写的Dapp<br>以太坊智能合约完全按照程序运行，杜绝了停机、去中心化操控、欺诈和第三方能干涉的可能性。<br>使用以太坊运行智能合约的主要优点是方面智能合约彼此交互，而且不需要担心整合共识协议等事情，只需编写应用所需逻辑即可。</li></ul><p>以太坊有一种内部货币叫做以太币ether，部署只能合约或者执行只能合约函数需要用到以太币。</p><ul><li>超级账本</li></ul><p>超级账本项目致力于开发创建授权的Dapp技术，Hyperledger fabric是Hyperledger项目的一个实现。</p><p>fabric是一个区中心化的授权平台，它允许在其上运行授权的Dapp。fabric是即插即用系统，可以方便地即插即用多种公式协议和功能。</p><ul><li>IPFS</li></ul><p>星际文件存储系统是一个去中心化的文件系统。使用分布式哈希表和Merkle有向无环图数据结构。它使用类似于BitTorrent比特流的协议来决定如何在网络中移动数据。</p><p>在文件系统中，所存储的内筒会一直保留到被删除之前每一个节点并不存储全部文件，存储的是需要的文件。</p><p>如果一个文件不那么受欢迎，许多节点就没有这个文件，那么该文件很有可能从网络中消失。</p><ul><li>Namecoin</li></ul><p>Namecoin是一个去中心化的键值数据库，它的内部货币叫做域名币。使用区块链数据结构和工作量证明共识协议。</p><ul><li>达世币</li></ul><p>达世币是一种类似于比特币的去中心化货币，使用区块链数据结构和工作量证明共识协议，并解决了比特币面临的一些主要问题。</p><ul><li>BigChainDB</li></ul><p>允许用户部署自己的、授权的或者免权限去中心化数据库，使用区块链数据结构以及其他多种特定数据库数据结构。</p><ul><li>OpenBazaar</li></ul><p>是一个去中心化的电子商务平台，可以在其上买卖物品，用户不是匿名的，因为IP被记录了，节点可以是买方、卖方或者中间人。</p><p>使用Kademlia分布式哈希表数据结构。</p><ul><li>Ripple</li></ul><p>瑞波是一个去中心化的转账平台，允许兑换货币、数字货币和大宗商品。使用区块链数据结构，并且有自己的共识协议。在Ripple相关文档中，找不到区块、区块链等词汇，用账本来代替。</p><p>瑞波币不是由挖矿生成的，最初就有1000亿个瑞波币，最初由Ripple公司拥有，是手动供给的。</p><h5 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h5>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
          <category> 《区块链项目开发指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）以太坊工作原理</title>
      <link href="/2017/12/02/etherum-desc/"/>
      <url>/2017/12/02/etherum-desc/</url>
      
        <content type="html"><![CDATA[<h5 id="2-1-以太坊概览"><a href="#2-1-以太坊概览" class="headerlink" title="2.1 以太坊概览"></a>2.1 以太坊概览</h5><p>以太坊是一个去中心化的平台，可以在其上部署Dapp，Dapp用一个或者更多个只能合约创建，使用Solidity编程语言编写只能合约。智能合约完全按照程序运行，而且防停机、防审查、防欺诈、防第三方干扰。</p><p>以太坊的内部货币为以太坊，部署智能合约或者调用其方法需要用到以太币。只能合约可以有多个实例，每个实例都有自己专门的地址，用户账户和智能合约都可以持有以太币。</p><p>以太坊使用区块链数据结构和工作量证明共识协议。</p><p>有两种网络中的节点：普通节点和矿工，普通节点只备份区块链上的数据，而矿工通过挖矿创建区块链。</p><a id="more"></a><h5 id="2-2-以太坊账户"><a href="#2-2-以太坊账户" class="headerlink" title="2.2 以太坊账户"></a>2.2 以太坊账户</h5><p>创建以太坊账户，只需要一个非对称加密密钥对 - 由不同算法生成，如RSA、ECC</p><p>以太坊使用ECC 椭圆曲线加密算法，它拥有多个参数来调节速度和安全性，以太坊使用secp256k1参数。</p><p>以太坊使用256位加密，公钥是一个256位数，被编译成长度为64的十六进制字符串</p><p>从公钥生成地址的过程如下：</p><pre><code>- 生成公钥的keccak-256哈希，给出一个256位数字- 丢弃前面的96位，即12个字节，得到160位二进制数据，20字节- 把地址编译成十六进制字符串，得到一个40字符串的字节串，就是账户地址</code></pre><h5 id="2-3-交易"><a href="#2-3-交易" class="headerlink" title="2.3 交易"></a>2.3 交易</h5><p>交易是一个签名数据包，用于从一个账户向另一个账户或者向一个合约转以太币、调用合约方法或者部署一个新合约。</p><p>交易使用椭圆曲线数字签名算法（ECDSA）签名、ECDSA是一种基于ECC的数字签名算法。</p><p>交易包含：</p><pre><code>-   信息接受者-   识别发起人及其意愿的签名-   要转账的以太币数量-   交易执行允许进行的计算资源最大值(gas上线)-   交易发起人愿意为单位计算资源支付的费用（gas价格）-   输入数据（如果调用合约方法）-   初始化代码（如果目的是部署合约）</code></pre><p><strong>交易费=交易消耗的gas * gas价格</strong></p><p>如果确定交易将永久出现在区块链中，则称交易已确认。</p><h5 id="2-4-共识"><a href="#2-4-共识" class="headerlink" title="2.4 共识"></a>2.4 共识</h5><p>以太坊使用工作量证明共识协议防止区块链被篡改。工作量证明系统需要解决一个复杂问题以创建一个新的区块。</p><p><strong>在工作量证明系统中，创建区块的过程称为挖矿，旷工是网络中挖区块的节点。</strong></p><p>网络安全不是用矿工总数衡量，而是用网络中的全部算力衡量。</p><p>区块链中有多少个区块没有限制，可以生成的以太币总数也没有限制。</p><p>为了挖区块，旷工首先从收到的广播中收集新的、未挖处处的交易，然后过滤掉不合法的交易。</p><p><strong><em>合法的交易必须满足正确的使用私钥签名、账户中有足够的余额进行交易等条件</em></strong></p><p>现在矿工创建一个有区块头和内容的区块，内容是区块包含的交易列表。</p><p>区块头包含前一个区块的哈希、区块序号、随机数、目标值、难度值、矿工地址等内容。</p><ul><li>时间戳表示区块初始时间</li><li>随机数是一个没有意义的值，纯粹是为了设置一个小于或等于目标值的区块哈希，以太坊使用ethash哈希算法，发现随机数的唯一方法是穷尽所有可能，目标值是一个256位的数字，根据不同的因素计算。</li></ul><p>区块头的难度值是目标值的一种不同表述方法，目标值越低，发现随机数需要的时间越多。目标值越高需要的时间越少。</p><p>计算问题难度值的公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_block_difficulty = previous_block_difficulty + previous_block_difficulty // 2048 * max(1 - (currency_block_timestamp - previous_block_timestamp) // 10, -99) + int(2 ** ((current_block_number // 1000) -  2))</span><br></pre></td></tr></table></figure></p><p>如果网络中的节点接收到两个不同的合法区块链，那么多有取款的整体难度值较高的那个区块链被视为合法的区块链。</p><h5 id="2-5-时间戳"><a href="#2-5-时间戳" class="headerlink" title="2.5 时间戳"></a>2.5 时间戳</h5><p>计算区块目标值的公式需要用到当前时间戳，且每个区块在区块头附加了当前时间戳。</p><p>没有什么机制可以阻止矿工在挖区块时使用其他时间戳(而非当前时间戳)。<br>时间戳验证失败，其他节点不会接受该区块，这样就浪费了矿工的资源。</p><p>当一个矿工广播一个新挖出的区块时，其他节点对其时间戳的验证取决于其时间戳是否大于前一个区块的时间戳。</p><h5 id="2-6-随机数"><a href="#2-6-随机数" class="headerlink" title="2.6 随机数"></a>2.6 随机数</h5><p>随机数是一个64位未签名证书。随机数是一个问题的解决办法，矿工不断尝试随机数，知道发现目标值。</p><p>每个矿工挖的区块的哈希是不同的，因为哈希取决于如时间戳、旷工地址等内容，而且对于所有狂公共来说这些内容很可能是不一样的。因此解决问题并不是一场比赛，而更像是意见碰运气的事</p><h5 id="2-7-区块时间"><a href="#2-7-区块时间" class="headerlink" title="2.7 区块时间"></a>2.7 区块时间</h5><p>我们看到的区块难度值公式使用了一个长达10s的阈值以确保挖出父区块和子区块的时间差在10~20s因为我们需要有一个相对稳定的生成区块的平均时间，即区块时间。</p><p>无效区块：两个矿工同时挖出了一个区块，网络最终会接受难度值较大的那个区块，被放弃的那个区块就是无效区块。</p><p>网络中生成的无效块总数与生成新的区块所需的平均时间成反比。难度越简单，区块时间越短，就有可能有更多的矿工挖出矿工，最终会舍弃很多区块。</p><p>无效块会影响区块链的安全，网络安全由网络中矿工的全部算力衡量，当算力增加时难度值也要增加，以确保区块不是在平均时间之前生成的</p><p>更高的难度值意味着更安全的区块链，因为篡改所需的算力会比多，而且最后不会被接受</p><p><strong>以太坊用ghost协议解决无效块带来的安全问题。</strong><br>ghost协议仅仅把无效块添加到母链上，掩盖了安全问题，由此增加了区块链的整体难度值（包括无效块的难度值之和）。</p><p>如何在不产生交易冲突的情况下把无效块添加到母链中呢？<br>事实上，任何一个区块链都可以接纳零个或者多个无效块</p><p>为了激励矿工接纳无效块，矿工接纳无效块也会得到回报，无效块中的交易不需要确认，无效块矿工也不想无效块接纳的交易收取交易费</p><p>在以太坊中 无效块称为 <strong>叔块</strong></p><p><strong>矿工接纳无效块得到的回报计算公式为</strong><code>(uncle_block_number+8-block_number) * 5 / 8</code></p><p>其余回报归侄块即包含孤块的区块。</p><h5 id="2-8-分叉"><a href="#2-8-分叉" class="headerlink" title="2.8 分叉"></a>2.8 分叉</h5><p>在节点验证区块链发生冲突时，会发生分叉 forking</p><p>分叉分为三种：</p><ul><li>普通分叉<blockquote><p>由于两个或者多个矿工几乎同时发现了一个区块引起的暂时冲突，如果一个区块的难度高于另一个，这个冲突就解决了。</p></blockquote></li><li>软分叉<blockquote><p>更改源代码，要求有50%以上算力的矿工升级。例如：更新源代码使得旧区块/交易的一部分失效，有50%以上算力矿工升级后可以解决，这样新的额区块链将有更大的难度值，最后被整个网络接受</p></blockquote></li><li>硬分叉<blockquote><p>更改源代码引起冲突，全部矿工升级，以解决冲突。例如更改源代码为了个更改对矿工的汇报，全部矿工都需要升级。</p></blockquote><h5 id="2-9-创世区块"><a href="#2-9-创世区块" class="headerlink" title="2.9 创世区块"></a>2.9 创世区块</h5></li></ul><p>genesis block，区块链中的第一个区块，其区块序号是0。</p><p>只有网络中的两个节点有相同的创世区块，他们才会彼此配对进行同步，否则他们将会彼此拒绝。<br>每一个节点生成自己的创世区块<br>对于不同的网络，创世区块被硬编到客户端里</p><h5 id="2-10-以太币面值"><a href="#2-10-以太币面值" class="headerlink" title="2.10 以太币面值"></a>2.10 以太币面值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1以太币 = 1000000000000000000 wei（18个0 100万千亿）</span><br><span class="line"></span><br><span class="line">        = 1000000000000000    Kwei</span><br><span class="line"></span><br><span class="line">        = 1000000000000       Mwei</span><br><span class="line"></span><br><span class="line">        = 1000000000          Gwei</span><br><span class="line"></span><br><span class="line">        = 1000000             Szabo</span><br><span class="line"></span><br><span class="line">        = 1000                Finnery</span><br><span class="line"></span><br><span class="line">        = 0.01                Kether</span><br></pre></td></tr></table></figure><h5 id="2-11-以太坊虚拟机"><a href="#2-11-以太坊虚拟机" class="headerlink" title="2.11 以太坊虚拟机"></a>2.11 以太坊虚拟机</h5><p>以太坊虚拟机是以太坊只能合约字节码执行环境，网络中的每个节点都运行EVM，所有节点执行使用EVM指向智能合约的全部交易，因此他们进行同样的计算，并存储同样的数值</p><p>出于各种原因，每个节点执行并存储最终状态。</p><p>有两种EVM实现</p><ul><li>字节码VM</li><li>JIT-VM<br>在两种情况下Solidity代码被编译成字节码，在JIT-VN中，字节码编译更充分，比字节码VM更高效</li></ul><h5 id="2-12-gas"><a href="#2-12-gas" class="headerlink" title="2.12 gas"></a>2.12 gas</h5><p>计算资源的计量单位。</p><p>每个交易包含gas上限和为每个gas支付费用的单价</p><h5 id="2-13-发现对等节点"><a href="#2-13-发现对等节点" class="headerlink" title="2.13 发现对等节点"></a>2.13 发现对等节点</h5><p>节点不需要连接到网络中的每一个节点，它只连接到几个其他节点，这些节点再连接到另外一个节点，按照这个方式，整个网络彼此连接。</p><p>以太坊有自己的节点发现协议可用于解决发现网络中的其他节点。该协议以Kadelima协议为基础。</p><p>在节点发现协议中有一个特殊节点，叫做<strong>Bootstrap节点</strong>，它保存了一段时间内与他们连接的所有的节点的列表，但其本身不保存区块链。</p><p>当对等节点连接到以太坊网络时，他们首先连接到BootStrap节点，然后由它连接到他们的对等节点列表，然后对等节点与对等节点连接并同步。</p><p>以太坊网络有两种</p><ul><li>主网<blockquote><p>用于交易</p></blockquote></li><li>测试网络<blockquote><p>供开发人员测试</p></blockquote><h5 id="2-14-Whisper和Swarm"><a href="#2-14-Whisper和Swarm" class="headerlink" title="2.14 Whisper和Swarm"></a>2.14 Whisper和Swarm</h5></li></ul><p>Whisper和Swarm分别是去中心化的通信协议和存储平台，由以太坊开发人员开发。</p><ul><li>Whisper：去中心化的通信协议 <a href="https://github.com/ethereum/wiki/wili/Whisper" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wili/Whisper</a><blockquote><p>允许网络中的节点彼此通信，支持广播、用户到用户、加密信息等，但不用于传输数据</p></blockquote></li><li>Swarm：去中心化的文件系统 <a href="https://github.com/ethersphere/go-ethereum/wiki/IPFS-&amp;-SWARM" target="_blank" rel="noopener">https://github.com/ethersphere/go-ethereum/wiki/IPFS-&amp;-SWARM</a><blockquote><p>类似于Filecoin，最大的区别是技术细节和激励机制。Filecoin不惩罚存储，Swarm惩罚存储，进一步提高的文件的可用性</p></blockquote></li></ul><p>仍在开发中</p><h5 id="2-15-geth"><a href="#2-15-geth" class="headerlink" title="2.15 geth"></a>2.15 geth</h5><p>是以太坊、Whisper和Swarm节点的一个实现，可以成为全部实现或者一些选定实现的一部分，合并他们的目的是让他们看起来想一个单一的Dapp，通过一个节点客户端可以访问三个dapp</p><p>geth是一种CLI应用，使用Go语言编写，在主要的操作系统中都可以使用。</p><h6 id="2-15-1-安装"><a href="#2-15-1-安装" class="headerlink" title="2.15.1 安装"></a>2.15.1 安装</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew tap ethereum/erhereum</span><br><span class="line">brew install geth</span><br><span class="line"></span><br><span class="line">#ubuntu</span><br><span class="line">sudo apt-get install software-properties-commin</span><br><span class="line">sudo add-apt-repository -y ppa:etherum/ethereum</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ethereum</span><br></pre></td></tr></table></figure><h5 id="2-15-2-JSON-RPC和JavaScript操作台"><a href="#2-15-2-JSON-RPC和JavaScript操作台" class="headerlink" title="2.15.2 JSON-RPC和JavaScript操作台"></a>2.15.2 JSON-RPC和JavaScript操作台</h5><p><a href="https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/wiki/JavaScript-Console</a><br>geth为其他应用提供了与其通信的JSON-RPC API geth使用HTTP、WebSocket和其他协议服务于JSON-RPC API</p><p>JSON-RPC API分为：</p><ul><li>admin</li><li>debug</li><li>eth</li><li>miner</li><li>net</li><li>personal</li><li>shh</li><li>txpool</li><li>web3<br>等类型</li></ul><h6 id="2-15-3-子命令和选项"><a href="#2-15-3-子命令和选项" class="headerlink" title="2.15.3 子命令和选项"></a>2.15.3 子命令和选项</h6><ul><li><p>连接至主网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir &apos;/usr/mnt/eth&apos; --networkid 1</span><br><span class="line"></span><br><span class="line">//--datadir 指定在哪里存储区块链默认路径[$HOME/.ethereum]</span><br><span class="line">//--networkid 指定网络ID 1代表主网络 2代表测试网络，默认为1</span><br></pre></td></tr></table></figure></li><li><p>创建私有网络</p></li></ul><p>只需要给出一个随机网络ID即可。通常创建私有网络的目的是进行开发，可以简单使用–dev 标记运行一个私有网络</p><h6 id="2-15-4-创建账户"><a href="#2-15-4-创建账户" class="headerlink" title="2.15.4 创建账户"></a>2.15.4 创建账户</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建新账户</span><br><span class="line">geth account new</span><br><span class="line">//获取用户所有列表,秘钥默认存储在--datadir路径中，可以使用--keystore选项指定一个不同的目录</span><br><span class="line">geth account list</span><br></pre></td></tr></table></figure><ul><li>挖矿</li></ul><p>默认geth不启动挖矿，提供–mine选项就可以进行挖矿，还有一些其他的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--mine 开始挖矿</span><br><span class="line">--minerthreads 执行哈希过程中使用的线程总数，默认使用8个线程</span><br><span class="line">--etherbase 挖矿赚取的回报存入的地址</span><br><span class="line">#账户默认是加密的，所以要访问账户中的以太币，需要解锁。</span><br><span class="line">--unlock 解锁一个或者多个账户，使用逗号分隔地址可以提供多个地址</span><br><span class="line"></span><br><span class="line">geth --mine --minerthreads 16 --etherbase &apos;5415b18cd4802c5bc3ab0c28a40c2f840623a956&apos; --unlock &apos;5415b18cd4802c5bc3ab0c28a40c2f840623a956&apos;</span><br></pre></td></tr></table></figure><ul><li>快速同步</li></ul><p>不下载整个区块，只下载区块头、交易凭证和最新的状态数据库。</p><p>为了检查区块链的真实性，该算法在每一个已定义的区块序号之后下载一个完整的区块<br>快速同步算法 <a href="https://github.com/ethereum/go-ethereum/pull/1889" target="_blank" rel="noopener">https://github.com/ethereum/go-ethereum/pull/1889</a></p><p>在运行geth过程中使用–fast即可<br>fast sync只在初始同步时运行，在节点成功与网络同步之后，fast sync就永远禁用了</p><h5 id="2-16-以太坊钱包"><a href="#2-16-以太坊钱包" class="headerlink" title="2.16 以太坊钱包"></a>2.16 以太坊钱包</h5><p>以太坊钱包使用IPC与geth通信，geth支持以文件为基础的IPC</p><h5 id="2-17-浏览器钱包"><a href="#2-17-浏览器钱包" class="headerlink" title="2.17 浏览器钱包"></a>2.17 浏览器钱包</h5><p>浏览器钱包Mist是以太坊、Whisper和Swarm的一个客户端，允许用户发送交易、发送Whisper信息、检查区块链等</p><h5 id="2-18-以太坊的缺点"><a href="#2-18-以太坊的缺点" class="headerlink" title="2.18 以太坊的缺点"></a>2.18 以太坊的缺点</h5><ul><li><p>Sybil攻击</p><blockquote><p>攻击者视图用它控制的普通节点占满整个网络，用户很有可能只连接到攻击者节点，一旦连接到攻击值节点，攻击者可以拒绝所有节点转播区块和交易，从而将用户网络中断开，攻击者只能转播他创建的区块，从而会将用户放到分开的网络上。</p></blockquote></li><li><p>51%攻击</p><blockquote><p>如果攻击者掌握了网络中一半以上的算力，他就可以比网络中的其他人更快生成区块，可以保留它的私有分叉，知道分叉比诚实网络创造的更长，然后广播自己的分叉<br>还可以重写交易，阻止一些交易被挖出，并阻止其他矿工挖出的区块被添加到区块链中。</p></blockquote><h5 id="2-19-serenity"><a href="#2-19-serenity" class="headerlink" title="2.19 serenity"></a>2.19 serenity</h5></li></ul><p>以太坊下一个主要更新的名字。这个更新将要求硬分叉，把共识协议改为casper，并将整合状态通道和分片。</p><h5 id="2-20-总结"><a href="#2-20-总结" class="headerlink" title="2.20 总结"></a>2.20 总结</h5>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
          <category> 《区块链项目开发指南》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ether </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>beginning-c-nine</title>
      <link href="/2017/11/09/beginning-c-nine/"/>
      <url>/2017/11/09/beginning-c-nine/</url>
      
        <content type="html"><![CDATA[<p>在程序进行通常的编译之前先对程序中的这些特殊命令进行预处理，再由编译程序对预处理后的源程序进行通常的编译处理，得到可供执行的目标代码</p><p>预处理、编译、连接</p><p>C提供的预处理功能主要有三种1、宏定义2、文件包含3、条件编译 均以#开头</p><h3 id="9-1-宏定义"><a href="#9-1-宏定义" class="headerlink" title="9.1 宏定义"></a>9.1 宏定义</h3><h4 id="9-1-1-不带参数的宏定义"><a href="#9-1-1-不带参数的宏定义" class="headerlink" title="9.1.1 不带参数的宏定义"></a>9.1.1 不带参数的宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure><h4 id="9-1-2-带参数的宏定义"><a href="#9-1-2-带参数的宏定义" class="headerlink" title="9.1.2 带参数的宏定义"></a>9.1.2 带参数的宏定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">带参数的宏定义不是进行简单的字符串替换，还要进行参数替换</span><br><span class="line"><span class="meta">#deine 宏名(参数表) 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S(a,b) a*b</span></span><br><span class="line"></span><br><span class="line">area = S(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">area = <span class="number">3</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="9-2-文件包含处理"><a href="#9-2-文件包含处理" class="headerlink" title="9.2 文件包含处理"></a>9.2 文件包含处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"文件名"</span><span class="comment">//系统先在用户当前目录中寻找要包含的文件，若找不到再按照标准方式查找</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;//系统存放C库函数都文件的目录中寻找要包含的文件，成为标准方式</span></span></span><br><span class="line"></span><br><span class="line">自己的用<span class="string">""</span>，系统的用&lt;&gt;</span><br><span class="line"></span><br><span class="line">包含了之后就是一个文件了</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="9-3-条件编译"><a href="#9-3-条件编译" class="headerlink" title="9.3 条件编译"></a>9.3 条件编译</h3><p>一般情况下，源程序中所有行都参加编译，但有时希望程序中一部分内容只在满足一定条件下才进行编译，也就是对这一部分指定编译的条件，这就是条件编译</p><p>形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> 标识符</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPUTER_A</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INTEGER_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> INTEGER_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（八）函数</title>
      <link href="/2017/11/08/beginning-c-eight/"/>
      <url>/2017/11/08/beginning-c-eight/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一个函数中调用另一个函数，需要具备的条件如下：<br>1、首先被调用的函数必须是已经存在的函数(库函数或者用户自己定义的函数)<br>2、如果使用库函数，需要再本文件开头用#include命令调用有关函数库时所需要的信息包含到本文件中<br>3、如果使用用户自己定义的函数，而该函数的位置在调用他的函数的后面，应该在主调用幻术中对被调用的函数作声明</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> add（<span class="keyword">float</span> x, <span class="keyword">float</span> y）;<span class="comment">//对函数add声明</span></span><br><span class="line">    <span class="keyword">float</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f,%f,%f"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    c = add(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum is %f\n"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span><span class="comment">//函数首部</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> z;                <span class="comment">//函数体</span></span><br><span class="line">    z = x + y;</span><br><span class="line">    <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">类型标识符 函数名()</span><br><span class="line">&#123;</span><br><span class="line">    声明部分</span><br><span class="line">    语句部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    z = x&gt;y ? x : y;</span><br><span class="line">    <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">verage</span><span class="params">(<span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">10</span>];aver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> aver,sum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    aver = sum/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> aver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h4><h4 id="变量的存储类别"><a href="#变量的存储类别" class="headerlink" title="变量的存储类别"></a>变量的存储类别</h4><h5 id="动态存储方式与静态存储方式"><a href="#动态存储方式与静态存储方式" class="headerlink" title="动态存储方式与静态存储方式"></a>动态存储方式与静态存储方式</h5><blockquote><p>全局变量全部存放在静态存储区中，在程序开始执行的时候给全局变量分配存储区，程序执行完就释放，在程序执行过程中他们占据固定的存储单元，而不是动态得进行分配和释放</p></blockquote><blockquote><p>动态存储区中存放的数据有<br>1、函数形式参数，在调用函数时给形参分配空间<br>2、自动变量 为加staic生命的局部变量<br>3、函数调用时的现场保护和返回地址等</p></blockquote><h4 id="auto变量"><a href="#auto变量" class="headerlink" title="auto变量"></a>auto变量</h4><p>函数中的局部变量，如果不专门生命为static存储类别，都是动态的分配存储空间，数据存储在动态存储区中。因此这类局部变量称为自动变量，用关键字auto作存储类别的声明</p><h4 id="static声明局部变量"><a href="#static声明局部变量" class="headerlink" title="static声明局部变量"></a>static声明局部变量</h4><p>如果希望函数中的局部变量的值在函数调用后不消失而保留原值，使其占用的存储单元不释放，在下一次该函数调用时，该变量已优质，就是上一次函数调用结束时的值，这时就应指该局部变量为静态局部变量，用static进行声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,f(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">    staic <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    b = b+<span class="number">1</span>;</span><br><span class="line">    c = c+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>(a+b+c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="register变量"><a href="#register变量" class="headerlink" title="register变量"></a>register变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">寄存器变量</span><br><span class="line"></span><br><span class="line">一般情况下，变量的值是存放在内存中，当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中，经过运算器进行计算，如果需要村塾，再从运算器将数据送到内存中存放</span><br><span class="line"></span><br><span class="line">如果一些变量使用频繁，那么就浪费很多是按在运算器和内存的读取上，，为了提高效率，C语言允许将局部变量的值放在CPU的寄存其中，需要时直接从寄存器中取出参加运算，不必再到内存中去存取，由于寄存器的存取速度远高于内存的存取速度，因此可以提高执行效率</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> main（）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> i,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,i,fac(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> i,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f=f*i;</span><br><span class="line">        <span class="keyword">return</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li>只有局部自动变量和形式参数可以作为寄存器变量，其他不行，在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束释放寄存器，此后，在调用另一个函数时又可以利用他来存放该函数的寄存器变量</li><li>一个计算机系统中的寄存器数目是有限的，不能定义任意多个寄存器变量</li><li>局部静态变量不能定义为寄存器变量，不能写成 register static int a,b,c,不能把变量a,b,c既存放在静态存储中又存放在寄存器中，二者只能居其一</li></ul><h4 id="用extrn声明外部变量"><a href="#用extrn声明外部变量" class="headerlink" title="用extrn声明外部变量"></a>用extrn声明外部变量</h4><h4 id="用static声明外部变量"><a href="#用static声明外部变量" class="headerlink" title="用static声明外部变量"></a>用static声明外部变量</h4><h4 id="关于变量的声明和定义"><a href="#关于变量的声明和定义" class="headerlink" title="关于变量的声明和定义"></a>关于变量的声明和定义</h4><h4 id="存储类别小结"><a href="#存储类别小结" class="headerlink" title="存储类别小结"></a>存储类别小结</h4><h3 id="内部函数和外部函数"><a href="#内部函数和外部函数" class="headerlink" title="内部函数和外部函数"></a>内部函数和外部函数</h3><h4 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h4><p>如果一个函数只能被文件中其他函数使用，成为内部函数用static声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br></pre></td></tr></table></figure></p><h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果在函数前添加了extern表示此函数是外部函数，可供其他文件调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">extrn <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（七）数组</title>
      <link href="/2017/11/07/beginning-c-seven/"/>
      <url>/2017/11/07/beginning-c-seven/</url>
      
        <content type="html"><![CDATA[<h3 id="7-1-一维数组的定义"><a href="#7-1-一维数组的定义" class="headerlink" title="7.1 一维数组的定义"></a>7.1 一维数组的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子用数组来处理就Fibonacci数列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">20</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i<span class="number">-2</span>] + f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%12d"</span>,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-二维数组的定义和引用"><a href="#7-2-二维数组的定义和引用" class="headerlink" title="7.2 二维数组的定义和引用"></a>7.2 二维数组的定义和引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a[<span class="number">3</span>][<span class="number">4</span>],b[<span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-3-字符数组"><a href="#7-3-字符数组" class="headerlink" title="7.3 字符数组"></a>7.3 字符数组</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'I'</span>,<span class="string">'a'</span>,<span class="string">'m'</span>,<span class="string">'h'</span>&#125;;</span><br><span class="line">char doamond[5][5] = &#123;&#123;'','','*'&#125;,&#123;'','*','','*'&#125;&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="字符数组的输入输出"><a href="#字符数组的输入输出" class="headerlink" title="字符数组的输入输出"></a>字符数组的输入输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">"china"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">c h i n a \<span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h4><h5 id="puts函数"><a href="#puts函数" class="headerlink" title="puts函数"></a>puts函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="string">"China \n Bei jing"</span>&#125;;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h5 id="gets函数"><a href="#gets函数" class="headerlink" title="gets函数"></a>gets函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(str);</span><br></pre></td></tr></table></figure><h4 id="strcat函数"><a href="#strcat函数" class="headerlink" title="strcat函数"></a>strcat函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcat</span>是<span class="built_in">string</span> catenate 的缩写，其作用是连接两个字符数组中的字符串</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="string">"nihao"</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">10</span>] = &#123;<span class="string">"a"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">strcat</span>(a,b));<span class="comment">//nihao a</span></span><br></pre></td></tr></table></figure><h4 id="strcpy-和strncpy"><a href="#strcpy-和strncpy" class="headerlink" title="strcpy 和strncpy"></a>strcpy 和strncpy</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>是<span class="built_in">string</span> copy的所系，是字符串复制函数，作用是将字符串<span class="number">2</span>复制到字符串数组<span class="number">1</span>中去</span><br><span class="line"></span><br><span class="line">char a[10] = '';</span><br><span class="line">char b[10] = 'copy';</span><br><span class="line"><span class="built_in">strcpy</span>(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, b);<span class="comment">//copy</span></span><br><span class="line"><span class="built_in">strcpy</span>(a,<span class="string">"china"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(str1,str2,n);<span class="comment">//将字符串前n个字符复制到str1中去</span></span><br></pre></td></tr></table></figure><h4 id="strcmp函数"><a href="#strcmp函数" class="headerlink" title="strcmp函数"></a>strcmp函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比较字符串<span class="number">1</span>和字符串<span class="number">2</span>，从做到右按照ASCII码值比较直到出现不同的字符或者遇到\<span class="number">0</span>截止</span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2);</span><br><span class="line">str1 = str2 返回<span class="number">0</span></span><br><span class="line">str1 &gt; str2 返回正整数</span><br><span class="line">str1 &lt; str2 返回负整数</span><br></pre></td></tr></table></figure><h4 id="strlen函数"><a href="#strlen函数" class="headerlink" title="strlen函数"></a>strlen函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回字符串长度</span><br><span class="line"><span class="built_in">strlen</span>(<span class="string">"china"</span>);<span class="comment">//5 不包含\0</span></span><br></pre></td></tr></table></figure><h4 id="strlwr-函数"><a href="#strlwr-函数" class="headerlink" title="strlwr 函数"></a>strlwr 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlwr(str)<span class="comment">//将字符串中的大写转换成小写</span></span><br></pre></td></tr></table></figure><h3 id="strup函数"><a href="#strup函数" class="headerlink" title="strup函数"></a>strup函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strup(str)<span class="comment">//将字符串中的小写转换成大写</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（四）最简单的C程序设计</title>
      <link href="/2017/11/05/beginning-c-4-5-6/"/>
      <url>/2017/11/05/beginning-c-4-5-6/</url>
      
        <content type="html"><![CDATA[<h3 id="4-1-C语句概述"><a href="#4-1-C语句概述" class="headerlink" title="4.1 C语句概述"></a>4.1 C语句概述</h3><h3 id="4-2-赋值语句"><a href="#4-2-赋值语句" class="headerlink" title="4.2 赋值语句"></a>4.2 赋值语句</h3><h3 id="4-3-数据输入输出的概念及在C语言中的实现"><a href="#4-3-数据输入输出的概念及在C语言中的实现" class="headerlink" title="4.3 数据输入输出的概念及在C语言中的实现"></a>4.3 数据输入输出的概念及在C语言中的实现</h3><h3 id="4-4-字符数据的输入输出"><a href="#4-4-字符数据的输入输出" class="headerlink" title="4.4 字符数据的输入输出"></a>4.4 字符数据的输入输出</h3><h4 id="4-4-1-putchar-函数"><a href="#4-4-1-putchar-函数" class="headerlink" title="4.4.1 putchar 函数"></a>4.4.1 putchar 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a,b,c;</span><br><span class="line">    a = <span class="string">'B'</span>;</span><br><span class="line">    b = <span class="string">'O'</span>;</span><br><span class="line">    c = <span class="string">'Y'</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(a);<span class="built_in">putchar</span>(b);<span class="built_in">putchar</span>(c);<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="comment">//BOY</span></span><br><span class="line">    </span><br><span class="line">    putchar('\101');//A</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\''</span>);<span class="comment">//'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-getchar函数"><a href="#4-4-2-getchar函数" class="headerlink" title="4.4.2 getchar函数"></a>4.4.2 getchar函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数的值就是从出入设备得到的字符</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    c = getchar();<span class="comment">//运行时，如果从键盘输入 a,只有在按Enter键之后才会从到内存</span></span><br><span class="line">    <span class="built_in">putchar</span>(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getchar只能接受一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-格式输入与输出"><a href="#4-5-格式输入与输出" class="headerlink" title="4.5 格式输入与输出"></a>4.5 格式输入与输出</h3><h4 id="4-5-1-printf函数"><a href="#4-5-1-printf函数" class="headerlink" title="4.5.1 printf函数"></a>4.5.1 printf函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式控制,输出表列)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%c"</span>,a,b);</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>格式字符</strong><br>在输入出时对不同类型的数据要使用不同的格式字符</p><p>d 格式符 用来输出十进制整数<br>%d 十进制整数数据的实际长度输出<br>%md m为指定的输出字段的宽度，不足m为，以空格补齐<br>%ld 输出长整型数据</p><p>o格式符 以8进制整数形式输出<br>x格式符 以16进制形式输出整数<br>u格式符 输出unsigned型数据，以十进制整数形式输出<br>c格式符 输出一个字符<br>s格式符 输出一个字符串<br>f格式符 输出实数，包括双精度、单精度，以小数形式输出<br>e格式符 以指数形式输出实数</p><h4 id="4-5-2-scanf函数"><a href="#4-5-2-scanf函数" class="headerlink" title="4.5.2 scanf函数"></a>4.5.2 scanf函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(格式控制,地址表列)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//&amp;是地址运算符，&amp;a指a在内存中的地址，这个语句的作用是按照a,b,c在内存的地址将a,b,c的值存进去</span></span><br></pre></td></tr></table></figure><h3 id="4-6-顺序结构程序设计举例"><a href="#4-6-顺序结构程序设计举例" class="headerlink" title="4.6 顺序结构程序设计举例"></a>4.6 顺序结构程序设计举例</h3><h2 id="第5章-选择结构程序设计"><a href="#第5章-选择结构程序设计" class="headerlink" title="第5章 选择结构程序设计"></a>第5章 选择结构程序设计</h2><h2 id="第6章-循环控制"><a href="#第6章-循环控制" class="headerlink" title="第6章 循环控制"></a>第6章 循环控制</h2><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><h4 id="6-2-goto语句以及用goto语句构成循环"><a href="#6-2-goto语句以及用goto语句构成循环" class="headerlink" title="6.2 goto语句以及用goto语句构成循环"></a>6.2 goto语句以及用goto语句构成循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    loop:<span class="keyword">if</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum+i;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">goto</span> loop;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-while循环"><a href="#6-3-while循环" class="headerlink" title="6.3 while循环"></a>6.3 while循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=sum+i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-do…while-循环"><a href="#6-4-do…while-循环" class="headerlink" title="6.4 do…while 循环"></a>6.4 do…while 循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(i&lt;<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-for循环"><a href="#6-5-for循环" class="headerlink" title="6.5 for循环"></a>6.5 for循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-循环嵌套"><a href="#6-6-循环嵌套" class="headerlink" title="6.6 循环嵌套"></a>6.6 循环嵌套</h3><h3 id="6-7-比较"><a href="#6-7-比较" class="headerlink" title="6.7 比较"></a>6.7 比较</h3><h3 id="6-8-break语句和continue语句"><a href="#6-8-break语句和continue语句" class="headerlink" title="6.8 break语句和continue语句"></a>6.8 break语句和continue语句</h3><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p>break可以跳出switch结构，继续执行switch语句下面的一个语句，也可以从循环体内跳出循环体，提前结束循环</p><h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h4><p>contunue;<br>其作用为结束本次循环，跳过循环体中下面尚未执行的语句接着执行下一次是否执行循环的判定</p><p>continue 和 break的区别是：continue语句只是结束本次循环，而不是终止整个循环的执行</p>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（三）数据类型、运算符与表达式</title>
      <link href="/2017/11/03/beginning-c-three/"/>
      <url>/2017/11/03/beginning-c-three/</url>
      
        <content type="html"><![CDATA[<h3 id="3-1-C语言的数据类型"><a href="#3-1-C语言的数据类型" class="headerlink" title="3.1 C语言的数据类型"></a>3.1 C语言的数据类型</h3><ul><li>基本类型<br>  整形、字符型、浮点型(单精度型、双精度型)、枚举类型</li><li>构造类型<br>  数组类型、结构体类型、共用体类型</li><li>指针类型</li><li>空类型</li></ul><h3 id="3-2-常量与变量"><a href="#3-2-常量与变量" class="headerlink" title="3.2 常量与变量"></a>3.2 常量与变量</h3><h4 id="3-2-1-常量和符号常量"><a href="#3-2-1-常量和符号常量" class="headerlink" title="3.2.1 常量和符号常量"></a>3.2.1 常量和符号常量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># define PRICE 30</span><br><span class="line"># include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-变量"><a href="#3-2-2-变量" class="headerlink" title="3.2.2 变量"></a>3.2.2 变量</h4><p>变量代表内存中具有特定属性的一个存储单元，用来存放数据，也就是变量的值</p><p>在对程序年一连接时由编译系统给每一个变量名分配对应的的内存地址，从变量中取值，实际上是通过变量名找到对应的内存地址，从该存储单元中读取数据</p><p><strong>C语言规定标识符只能由字母、数字和下划线3种字符组成，且第一个字符必须为字母或下划线</strong></p><a id="more"></a><h3 id="3-3-整型数据"><a href="#3-3-整型数据" class="headerlink" title="3.3 整型数据"></a>3.3 整型数据</h3><h4 id="3-3-1-整型常量的表示方法"><a href="#3-3-1-整型常量的表示方法" class="headerlink" title="3.3.1 整型常量的表示方法"></a>3.3.1 整型常量的表示方法</h4><ul><li>十进制整数<br>123,-456,</li><li>八进制整数<br>  以0开头的数是八进制数，如0123表示八进制数123，其值等于十进制 1<em>8^2 + 2 </em> 8^1 + 3 * 8^0</li><li>十六进制整数<br>  以0x开头的数是十六进制数，如0123代表十六进制123，其值等于十进制 1<em> 16^2 + 2 </em> 16^1 + 3 * 16^0</li></ul><h4 id="3-3-2-整型变量"><a href="#3-3-2-整型变量" class="headerlink" title="3.3.2 整型变量"></a>3.3.2 整型变量</h4><ul><li><p>整型数据在内存中的存放形式<br>  数据在内存中以二进制形式存放的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int i;//定义为整型变量</span><br><span class="line">i = 10;// 给i赋值以整数 10 </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">十进制数10的二进制形式为1010</span><br><span class="line">实际上，数值是以补码表示的。一个正整数的补码和该树的源码相同</span><br><span class="line">求负数的补码方法是：将该数的绝对值的二进制形式，按位取反再加1</span><br><span class="line"></span><br><span class="line">-10的补码</span><br><span class="line"></span><br><span class="line">10 的二进制形式 一个整数占16位</span><br><span class="line">0000000000001010    </span><br><span class="line">取反</span><br><span class="line">1111111111110101</span><br><span class="line">+1</span><br><span class="line">1111111111110110</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li><li><p>整型变量的分类</p><ul><li>基本整型 int    范围 -2^15 ~ 2^15-1   -32768 ~ 32768</li><li>短整型  short int</li><li>长整型  long int</li><li>有符号基本类型 [signed] int;</li><li>无符号基本类型 unsigned int;</li><li>有符号短整型   [signed] short [int];</li><li>无符号短整型   unsigned short [int];</li><li>有符号长整型   [signed] long  [int];</li><li>无符号长整型   unsigned long  [int];</li></ul></li></ul><blockquote><p>如果不指定unsigned 或者指定 signed，则存储单元中最高位代表符号(0为正，1为负)<br>如果指定unsigned，为无符号型，存储单元中全部二进制bit用作存放数本身，而不包含符号<br>无符号变量只能存放不带符号的证书，如123，4578，而不能存放负数<br>一个无符号整型变量中可以存放的正数的范围比一般整型变量中正数的范围扩大一倍 为0 ~ 65535</p></blockquote><p>short型都是16位<br>long型为32位<br>int型既可以是16位也可以是32位</p><ul><li><p>整型变量的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> c,d;</span><br><span class="line"><span class="keyword">long</span> e,f;</span><br></pre></td></tr></table></figure></li><li><p>整型数据溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b;<span class="comment">//-32767 ~ 32767 </span></span><br><span class="line">    a = <span class="number">32767</span>;<span class="comment">//0111111111111111</span></span><br><span class="line">    b = a + <span class="number">1</span>;<span class="comment">//1000000000000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>, a, b)<span class="comment">// 32767 -32768</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-3-整型常量的类型"><a href="#3-3-3-整型常量的类型" class="headerlink" title="3.3.3 整型常量的类型"></a>3.3.3 整型常量的类型</h4><p>整型变量分为int,short int, long int,unsigned intm unsigned short, unsigned long</p><p>在将一个整型常量复制给上述几种类别的整型变量时如何做到类型匹配</p><ul><li>在-32768 ~ 32767 之间 认为是int型，可以赋值给int型或者long int型</li><li>在-2147483648 ~ 2147483647 范围内，则认为是长整型，可以将它赋值给一个long int型变量</li><li>一个整型常量后面加一个u或者U认为是unsigned int型，如果协程-123u，则先将-123转换成其补码然后再按照无符号数存储</li><li>一个整常量后面加一个字母l或者L，则认为是long int型常量</li></ul><h3 id="3-4-浮点型数据"><a href="#3-4-浮点型数据" class="headerlink" title="3.4 浮点型数据"></a>3.4 浮点型数据</h3><h4 id="3-4-1-浮点型常量的表示方法"><a href="#3-4-1-浮点型常量的表示方法" class="headerlink" title="3.4.1 浮点型常量的表示方法"></a>3.4.1 浮点型常量的表示方法</h4><ul><li>十进制小数形式<br>  0.123</li><li>指数形式<br>  123e3</li></ul><h4 id="3-4-2浮点型变量"><a href="#3-4-2浮点型变量" class="headerlink" title="3.4.2浮点型变量"></a>3.4.2浮点型变量</h4><ul><li>浮点型数据在内存中的存放形式<br>  一个浮点型数据一般在内存中占4个字节(32位)，按照指数形式存储<h2 id="系统把一个浮点型数据分成小数部分和指数部分，分别存放，指数部分采用规范化的指数形式"><a href="#系统把一个浮点型数据分成小数部分和指数部分，分别存放，指数部分采用规范化的指数形式" class="headerlink" title="  系统把一个浮点型数据分成小数部分和指数部分，分别存放，指数部分采用规范化的指数形式"></a>  系统把一个浮点型数据分成小数部分和指数部分，分别存放，指数部分采用规范化的指数形式</h2><h2 id="3-1-4-1-5-9-1"><a href="#3-1-4-1-5-9-1" class="headerlink" title="  |+| . 3 1 4 1 5 9 | 1|"></a>  |+| . 3 1 4 1 5 9 | 1|</h2>  数符    小数部分    指数<ul><li>.314159  *  10^1 = 3.14159</li></ul></li><li>多少位表示小数部分，多少位标书指数部分无具体规定，由c语言编译系统自定，不少以24位表示小数部分，8为表示指数部分，小数部分bit越多，数的有效数字越多，精度也就越高。指数部分占的越多，表示数值范围越大</li><li>浮点型变量的分类<br>  单精度 float            32位    6~7位有效数<br>  双精度 double           64位    15~16 位<br>  长双精度 long double    128位   18~19 位</li><li>浮点类型数据的舍入误差<br>  print函数中%f 是输出浮点数时指定的格式符，作用是指定该实数以小数形式输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a,b;</span><br><span class="line">    a = <span class="number">123456.789e5</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,b);<span class="comment">//12345678848.00000</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    程序运行时输出b的值与a相等，a的值笔20大很多，a+20的理论只应该是12345678920，而一个浮点类型变量只能保证的有效数字是7位，后面的数字是无意义的，因此并不准确表示该数</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    应当避免将一个很大的数和一个很小的数直接相加或相减，否则就会丢失小数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-4-3-浮点型常量的类型"><a href="#3-4-3-浮点型常量的类型" class="headerlink" title="3.4.3 浮点型常量的类型"></a>3.4.3 浮点型常量的类型</h4><p>C语言编译系统将浮点型常量作为双精度来处理。</p><h3 id="3-5-字符型数据"><a href="#3-5-字符型数据" class="headerlink" title="3.5 字符型数据"></a>3.5 字符型数据</h3><h4 id="3-5-1-字符常量"><a href="#3-5-1-字符常量" class="headerlink" title="3.5.1 字符常量"></a>3.5.1 字符常量</h4><p>C语言的字符常量是用单引号括起来的一个字符’a’,’x’,’D’,’?’,’$’</p><p>C允许使用一种特殊形式的字符常量，以\开头</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\n -&gt; 换行</span><br><span class="line">\t -&gt; tab</span><br><span class="line">\b -&gt; 退格</span><br><span class="line">\r -&gt; 回车</span><br><span class="line">\f -&gt; 换页</span><br><span class="line">\\ -&gt; \</span><br><span class="line">\' -&gt; '</span><br><span class="line">\'' -&gt; ''</span><br></pre></td></tr></table></figure><p>字符变量定义<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1,c2;</span><br><span class="line">c1 = <span class="string">'a'</span>;</span><br><span class="line">c2 = <span class="string">'b'</span>;</span><br><span class="line">printf('%c', c1);// a</span><br><span class="line">printf('%d', c1);// 97</span><br></pre></td></tr></table></figure></p><p>大小写字符转换<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1,c2;</span><br><span class="line">    c1 = <span class="string">'a'</span>;</span><br><span class="line">    c2 = <span class="string">'b'</span>;</span><br><span class="line">    c1 = c1 - <span class="number">32</span>;</span><br><span class="line">    c2 = c2 - <span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %c"</span>, c1,c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-5-4字符串常量"><a href="#3-5-4字符串常量" class="headerlink" title="3.5.4字符串常量"></a>3.5.4字符串常量</h4><p>字符串常量是双引号引起来的字符序列</p><p>“how do you do”</p><p>不能把一个字符串常量赋给</p><blockquote><p>C规定：在每一个字符串常量的结尾加一个“字符串结束标志”，以便系统据此判断字符串是否结束。C规定以字符’\0’作为字符串结束标志。’\O’是一个ASCII码为0的字符，为空操作字符，它既不其任何控制动作，也不是一个可现实的字符，如果有一个字符串常量”CHINA”，实际在内存中是 C H I N A \0  占内存单元不是5个字符而是6个字符</p></blockquote><h3 id="3-6-变量赋初值"><a href="#3-6-变量赋初值" class="headerlink" title="3.6 变量赋初值"></a>3.6 变量赋初值</h3><h3 id="3-7-各类数值型数据间的混合运算"><a href="#3-7-各类数值型数据间的混合运算" class="headerlink" title="3.7 各类数值型数据间的混合运算"></a>3.7 各类数值型数据间的混合运算</h3><h3 id="3-8-算数运算符和算术表达式"><a href="#3-8-算数运算符和算术表达式" class="headerlink" title="3.8 算数运算符和算术表达式"></a>3.8 算数运算符和算术表达式</h3><h3 id="3-9-赋值运算符和赋值表达式"><a href="#3-9-赋值运算符和赋值表达式" class="headerlink" title="3.9 赋值运算符和赋值表达式"></a>3.9 赋值运算符和赋值表达式</h3><h3 id="3-10-逗号运算符和逗号表达式"><a href="#3-10-逗号运算符和逗号表达式" class="headerlink" title="3.10 逗号运算符和逗号表达式"></a>3.10 逗号运算符和逗号表达式</h3>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（二）程序的灵魂 - 算法</title>
      <link href="/2017/11/02/beginning-c-two/"/>
      <url>/2017/11/02/beginning-c-two/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-程序的灵魂-算法"><a href="#第2章-程序的灵魂-算法" class="headerlink" title="第2章 程序的灵魂 - 算法"></a>第2章 程序的灵魂 - 算法</h1><blockquote><p>一个程序包括一下两个方面的额内容：<br>1、对数据的描述<br>2、对操作的描述，即操作步骤 也就是算法</p></blockquote><h3 id="数据结构-算法-程序"><a href="#数据结构-算法-程序" class="headerlink" title="数据结构 + 算法 = 程序"></a>数据结构 + 算法 = 程序</h3><h3 id="2-1-算法的概念"><a href="#2-1-算法的概念" class="headerlink" title="2.1 算法的概念"></a>2.1 算法的概念</h3><p>广义的讲，为解决一个问题而采取的方法和步骤就称为算法</p><h3 id="2-2-算法举例"><a href="#2-2-算法举例" class="headerlink" title="2.2 算法举例"></a>2.2 算法举例</h3><h3 id="2-3-算法的特性"><a href="#2-3-算法的特性" class="headerlink" title="2.3 算法的特性"></a>2.3 算法的特性</h3><ul><li>有穷性</li><li>确定性</li><li>有零个或者多个输入</li><li>有一个或者多个输出</li><li>有效性</li></ul><h3 id="2-4-怎样表示一个算法"><a href="#2-4-怎样表示一个算法" class="headerlink" title="2.4 怎样表示一个算法"></a>2.4 怎样表示一个算法</h3><h4 id="2-4-1-用自然语言表示算法"><a href="#2-4-1-用自然语言表示算法" class="headerlink" title="2.4.1 用自然语言表示算法"></a>2.4.1 用自然语言表示算法</h4><p>自然语言就是人们日常使用的语言，可以是汉语、英语或其他语言，用自然语言表示通俗易懂，但文字冗长，容易出现歧义性</p><h4 id="2-4-2-用流程图表示算法"><a href="#2-4-2-用流程图表示算法" class="headerlink" title="2.4.2 用流程图表示算法"></a>2.4.2 用流程图表示算法</h4><p>用图形表示算法，直观形象，便于理解</p><h4 id="2-4-3-3中基本结构和改进的流程图"><a href="#2-4-3-3中基本结构和改进的流程图" class="headerlink" title="2.4.3 3中基本结构和改进的流程图"></a>2.4.3 3中基本结构和改进的流程图</h4><a id="more"></a><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul><h4 id="2-4-4-用N-S流程图表示算法"><a href="#2-4-4-用N-S流程图表示算法" class="headerlink" title="2.4.4 用N-S流程图表示算法"></a>2.4.4 用N-S流程图表示算法</h4><p>在流程图中完全去掉了带箭头的流程线，全部算法写在一个矩形框里，在该框内还可以包含其他的从属它的框，或者说由一些基本的框组成一个大的框。适用于结构化程序设计</p><h3 id="2-4-5-用伪代码表示算法"><a href="#2-4-5-用伪代码表示算法" class="headerlink" title="2.4.5 用伪代码表示算法"></a>2.4.5 用伪代码表示算法</h3><h3 id="2-4-6-用计算机语言表示算法"><a href="#2-4-6-用计算机语言表示算法" class="headerlink" title="2.4.6 用计算机语言表示算法"></a>2.4.6 用计算机语言表示算法</h3><p>C、C++</p><h3 id="2-5-结构化程序设计方法"><a href="#2-5-结构化程序设计方法" class="headerlink" title="2.5 结构化程序设计方法"></a>2.5 结构化程序设计方法</h3><p>一个结构化程序就是用高级语言表示的结构化算法，用3中基本结构组成的额程序必然是结构化的程序，这种程序便于编写、阅读、修改和维护，减少了出错的机会，提高了程序可靠性，保证了程序的质量</p><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul><li>自顶向下</li><li>逐步细化</li><li>模块化设计</li><li>结构化编码</li></ul><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li>什么是算法</li><li>什么是结构化算法，为什么提倡结构化算法</li><li>3中基本结构的特点</li><li>用自顶向下、逐步细化的方法进行算法设计</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（一）C语言概述</title>
      <link href="/2017/11/02/beginning-c-one/"/>
      <url>/2017/11/02/beginning-c-one/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-C语言出现的历史北京"><a href="#1-1-C语言出现的历史北京" class="headerlink" title="1.1 C语言出现的历史北京"></a>1.1 C语言出现的历史北京</h3><h3 id="1-2-C语言的特点"><a href="#1-2-C语言的特点" class="headerlink" title="1.2 C语言的特点"></a>1.2 C语言的特点</h3><ul><li>语言简洁、紧凑，使用方便灵活</li><li>运算符丰富</li><li>数据类型丰富，具有现代语言的各种数据结构</li><li>具有结构化的控制语句</li><li>语法限制不太严格，程序设计自由度大</li><li>C语言允许直接访问物理地址，能进行bit操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作</li><li>生成目标代码质量高，程序执行效率高</li><li>用C语言编写的程序可移植性好，基本不做修改就能用于各种型号的计算机和各种操作系统</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《C语言程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法</title>
      <link href="/2017/10/07/php-interview-prepare-algorithm/"/>
      <url>/2017/10/07/php-interview-prepare-algorithm/</url>
      
        <content type="html"><![CDATA[<h4 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h4><p>一个问题可以有多种算法，每种算法都有不同的效率<br>算法评定从时间复杂度和空间复杂度计算</p><h4 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h4><p><strong>时间复杂度：</strong> 执行算法所需要的计算工作量，一般来说，计算机算法是问题规模N的函数f(n),算法的时间复杂度也因此记作T（n）= O(f(n))</p><p>计算方式：</p><ul><li><p>得出算法的计算次数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+...+n</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n; i++)&#123;</span><br><span class="line">    $sum += i;</span><br><span class="line">&#125;</span><br><span class="line">#总共循环了n次，所以时间复杂度为O(n)</span><br></pre></td></tr></table></figure></li><li><p>用常数1来取代所有时间中的加法常数</p></li><li>在修改后的运行次数函数中，只保留最高阶</li><li>如果最高阶存在且不是1，则去除与这个数相乘的常数<blockquote><p>举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">test</span><span class="params">($n)</span> </span>&#123;</span><br><span class="line">    echo $n;</span><br><span class="line">    echo $n;</span><br><span class="line">    echo $n;</span><br><span class="line">&#125;</span><br><span class="line">#计算<span class="number">3</span>次，O(<span class="number">3</span>)--记作-&gt;O(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">1</span>; $i&lt;= $n;$i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> ($j = <span class="number">1</span>;$j&lt;=$n;$j++) &#123;</span><br><span class="line">        $sum += $j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#n * n 次 时间复杂度为O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">1</span>; $i&lt;= $n;$i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> ($j = <span class="number">1</span>;$j&lt;=$n;$j++) &#123;</span><br><span class="line">        $sum += $j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> () &#123;</span><br><span class="line">    n次</span><br><span class="line">&#125;</span><br><span class="line">echo $a + b </span><br><span class="line"><span class="meta">#n^2 + n + 1 ---&gt;忽略 --&gt; O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>($n&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    $n = $n/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#n执行次数</span></span><br><span class="line"></span><br><span class="line">n/(<span class="number">2</span>^m) = <span class="number">1</span></span><br><span class="line">#m = log2n,所以时间复杂度O(log2n)</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>效率排名：O(1)&gt;O(log2n)&gt;O(n)&gt;O(nlog2n)&gt;O(n^2) &gt; O(n^3) &gt; O(2^n) &gt; O(n!) &gt; O(n^n)</p><p>最坏的情况：最坏情况时的运行时间，一种保证，如果没有特别说明，说明时间复杂度为最坏的时间复杂度</p><a id="more"></a><p><strong>空间复杂度</strong></p><p>S(n) = O(f(n)),算法需要消耗的内存空间</p><p>包括程序代码、输入数据、辅助变量所占用的空间</p><p><em>计算方式：</em></p><p>有时用空间换取时间<br>冒泡排序的元素交换，空间复杂度就是O(1)</p><h4 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h4><p>冒泡排序、直接排序、希尔、选择、快速、堆、归并排序</p><ul><li>冒泡排序<blockquote><p>原理：两两相邻的数进行比较，如果反序就交换，否则不交换</p></blockquote></li></ul><blockquote><p>时间复杂度：最坏O(n^2),空间复杂度O(1)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#m冒泡排序</span></span><br><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span></span><br><span class="line"><span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>;$c = count($arr);$i&lt;$c;$i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>($j=<span class="number">0</span>;$j&lt;$c;$j++) &#123;</span><br><span class="line">        $arr[$j] = $arr[$j+<span class="number">1</span>];</span><br><span class="line">        $temp = $arr[$j];</span><br><span class="line">        <span class="keyword">if</span> ($arr[$j] &gt; $arr[$j+<span class="number">1</span>]) &#123;</span><br><span class="line">          $arr[$j+<span class="number">1</span>] = $temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接插入排序<blockquote><p>原理：每次从无序表中取出一个元素，把它插入到有序表的合适的位置，使有序表依然有序</p></blockquote></li></ul><blockquote><p>时间复杂度O(n^2),空间复杂度O(1)</p></blockquote><ul><li>希尔排序<blockquote><p>把待排序的数据很具增量分成几个子序列，对子序列进行插入排序，直到增量为1，直接进行插入排序；增量的排序一般是数组长度的一半，再变为原来增量的一般，知道增量为1</p></blockquote></li></ul><blockquote><p>时间复杂度O(n^2)空间复杂度O(1)</p></blockquote><ul><li>选择排序<blockquote><p>每次从待排序的数据元素中选出最小(或最大)的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完</p></blockquote></li></ul><blockquote><p>时间复杂度 O(n^2),空间复杂度O(1)</p></blockquote><ul><li>快速排序<blockquote><p>通过一趟排序将要排序的数据分割成独立的两个部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按照此方法对这两个部分数据进行快速排序，整个排序过程可以递归完成</p></blockquote></li></ul><blockquote><p>时间复杂度为最差O(n^2)平均O(nlog2n)<br>空间复杂度为O(n)，平均O(nlog2n)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(<span class="built_in">array</span> &amp;$arr,$a,$b)</span></span>&#123;</span><br><span class="line">    $temp = $arr[$a];</span><br><span class="line">    $arr[$a] = $arr[$b];</span><br><span class="line">    $arr[$b] = $temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Partition</span><span class="params">(<span class="built_in">array</span> &amp;$arr,$low,$high)</span></span>&#123;</span><br><span class="line">    $pivot = $arr[$low];   <span class="comment">//选取子数组第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>($low &lt; $high)&#123;  <span class="comment">//从数组的两端交替向中间扫描</span></span><br><span class="line">        <span class="keyword">while</span>($low &lt; $high &amp;&amp; $arr[$high] &gt;= $pivot)&#123;</span><br><span class="line">            $high --;</span><br><span class="line">        &#125;</span><br><span class="line">        swap($arr,$low,$high);<span class="comment">//终于遇到一个比$pivot小的数，将其放到数组低端</span></span><br><span class="line">        <span class="keyword">while</span>($low &lt; $high &amp;&amp; $arr[$low] &lt;= $pivot)&#123;</span><br><span class="line">            $low ++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap($arr,$low,$high);<span class="comment">//终于遇到一个比$pivot大的数，将其放到数组高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $low;   <span class="comment">//返回high也行，毕竟最后low和high都是停留在pivot下标处</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">QSort</span><span class="params">(<span class="built_in">array</span> &amp;$arr,$low,$high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($low &lt; $high)&#123;</span><br><span class="line">        $pivot = Partition($arr,$low,$high);  <span class="comment">//将$arr[$low...$high]一分为二，算出枢轴值</span></span><br><span class="line">        QSort($arr,$low,$pivot - <span class="number">1</span>);   <span class="comment">//对低子表进行递归排序</span></span><br><span class="line">        QSort($arr,$pivot + <span class="number">1</span>,$high);  <span class="comment">//对高子表进行递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">QuickSort</span><span class="params">(<span class="built_in">array</span> &amp;$arr)</span></span>&#123;</span><br><span class="line">    $low = <span class="number">0</span>;</span><br><span class="line">    $high = count($arr) - <span class="number">1</span>;</span><br><span class="line">    QSort($arr,$low,$high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>堆排序<blockquote><p>把待排序的元素按照大小在二叉树位置上排序，排序好的元素要满足：父节点的元素要大于等于子节点；这个过程叫做堆化过程，如果根节点存放的是最大的数，则叫做大跟堆，如果是最小，就叫小根堆，可以把节点拿出来，然后再堆化，循环到最后一个节点</p></blockquote></li></ul><blockquote><p>时间复杂度：O(nlog2n)<br>空间复杂度：O(1)</p></blockquote><ul><li>归并排序<blockquote><p>将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个有序的子序列，再把有序的子序列合并为整体有序序列</p></blockquote></li></ul><blockquote><p>时间复杂度O(nlog2n)<br>空间复杂度O(n)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(<span class="built_in">array</span> $arr,$a,$b)</span> </span>&#123;</span><br><span class="line">    $temp = $arr[$a];</span><br><span class="line">    $arr[$a] = $arr[$b];</span><br><span class="line">    $arr[$b = $temp];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并算法总函数</span></span><br><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(<span class="built_in">array</span> $arr)</span> </span>&#123;</span><br><span class="line">    $start = <span class="number">0</span>;</span><br><span class="line">    $end = count($arr) - <span class="number">1</span>;</span><br><span class="line">    Msort($arr,$start,$end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">functin <span class="title">Msort</span><span class="params">(<span class="built_in">array</span> &amp;$arr,$start,$end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当子序列长度为1时，$start == $end,不再分组</span></span><br><span class="line">    <span class="keyword">if</span> ($start &lt; $end) &#123;</span><br><span class="line">        $mid = <span class="built_in">floor</span>(($start + $end) / <span class="number">2</span>);<span class="comment">//将 $arr 平分为 $arr[$start - $mid] 和 $arr[$mid+1 - $end]</span></span><br><span class="line">        MSort($arr,$start,$mid);<span class="comment">//将 $arr[$start - $mid] 归并为有序的$arr[$start - $mid]</span></span><br><span class="line">        MSort($arr,$mid + <span class="number">1</span>,$end);<span class="comment">//将 $arr[$mid+1 - $end] 归并为有序的 $arr[$mid+1 - $end]</span></span><br><span class="line">        Merge($arr,$start,$mid,$end); <span class="comment">//将$arr[$start - $mid]部分和$arr[$mid+1 - $end]部分合并起来成为有序的$arr[$start - $end]</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并操作</span></span><br><span class="line"><span class="function">function <span class="title">Merge</span><span class="params">(<span class="built_in">array</span> &amp;$arr,$start,$mid,$end)</span></span>&#123;</span><br><span class="line">    $i = $start;</span><br><span class="line">    $j=$mid + <span class="number">1</span>;</span><br><span class="line">    $k = $start;</span><br><span class="line">    $temparr = <span class="built_in">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>($i!=$mid+<span class="number">1</span> &amp;&amp; $j!=$end+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>($arr[$i] &gt;= $arr[$j])&#123;</span><br><span class="line">           $temparr[$k++] = $arr[$j++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           $temparr[$k++] = $arr[$i++];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将第一个子序列的剩余部分添加到已经排好序的 $temparr 数组中</span></span><br><span class="line">    <span class="keyword">while</span>($i != $mid+<span class="number">1</span>)&#123;</span><br><span class="line">        $temparr[$k++] = $arr[$i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将第二个子序列的剩余部分添加到已经排好序的 $temparr 数组中</span></span><br><span class="line">    <span class="keyword">while</span>($j != $end+<span class="number">1</span>)&#123;</span><br><span class="line">        $temparr[$k++] = $arr[$j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>($i=$start; $i&lt;=$end; $i++)&#123;</span><br><span class="line">        $arr[$i] = $temparr[$i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="常见查找算法"><a href="#常见查找算法" class="headerlink" title="常见查找算法"></a>常见查找算法</h4><ul><li>二分查找<blockquote><p>从数组的中间元素开始，如果中间元素正好是要查找的元素，搜索结束，如果某一个特定元素大于或者小于中间元素，则在数组大于或者小于中间元素的一半中查找</p></blockquote></li></ul><blockquote><p>时间复杂度最差O（log2n）空间复杂度迭代o(1),递归O（nlog2n）</p></blockquote><ul><li>顺序查找<blockquote><p>按一定的顺序检查数组中的每一个元素，直到找到所要寻找的特定值为止</p></blockquote></li></ul><blockquote><p>时间复杂度：O(n) 空间复杂度O(1)</p></blockquote><h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><blockquote><p>1,1,2,3,5,8,13,21,34…第30位是多少？使用伪代码描述其实现方法。 伪代码就是文字描述就可以</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">2</span>;$i&lt;<span class="number">30</span>;$i++) &#123;</span><br><span class="line">    $arr[$i] = $arr[$i<span class="number">-1</span>] + $arr[$i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($arr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈对MVC工作原理的认识和常见的MVC框架</title>
      <link href="/2017/10/06/php-interview-prepare-php/"/>
      <url>/2017/10/06/php-interview-prepare-php/</url>
      
        <content type="html"><![CDATA[<h4 id="谈谈对MVC工作原理的认识和常见的MVC框架"><a href="#谈谈对MVC工作原理的认识和常见的MVC框架" class="headerlink" title="谈谈对MVC工作原理的认识和常见的MVC框架"></a>谈谈对MVC工作原理的认识和常见的MVC框架</h4><p>Model、View、Controller</p><p>数据模型层，视图层、控制器(业务处理层)</p><p>TP、Yii2、CI、Yaf</p><h4 id="单一入口工作原理"><a href="#单一入口工作原理" class="headerlink" title="单一入口工作原理"></a>单一入口工作原理</h4><p>用一个处理程序文件处理多有的HTTP请求，根据请求参数的模块去完成对应操作</p><p><strong>优势:</strong></p><ul><li>可以进行统一的安全性的检查</li><li>集中处理程序</li></ul><p><strong>劣势:</strong></p><ul><li>URL不美观</li><li>处理效率会稍低<h4 id="模板引擎的理解"><a href="#模板引擎的理解" class="headerlink" title="模板引擎的理解"></a>模板引擎的理解</h4></li></ul><p>PHP 是一种HTML内嵌的在服务器端执行的脚本语言，但是PHP有很多可以使PHP代码和HTML代码分开的模板引擎，例如Smarty，Twig，Haml</p><p>工作原理：<br>庞大的完善的正则表达式的替换库</p><h4 id="常见框架的特性考点"><a href="#常见框架的特性考点" class="headerlink" title="常见框架的特性考点"></a>常见框架的特性考点</h4><p>php框架有哪些，用过哪些，各自的优缺点是什么？</p><p>PHP框架的差异和优缺点</p><p><strong>Yaf框架</strong></p><p>使用php扩展的形式写的一个php矿建，以C语言为底层编写的，性能上要比PHP代码写的快一个数量级</p><p>优点：执行效率高，轻量级、扩展性高</p><p>缺点：高版本兼容性查、底层代码可读性差、需要安装扩展、功能单一、开发需要编写大量的插件</p><p><strong>Yii2框架</strong></p><p>Yii2框架是一款非常优秀的通用web后端框架，结构简单优雅，使用功能丰富，扩展性强，性能高</p><p>缺点：<br>学习成本高，量级重</p><p>常见框架的特性</p><p>Yii2的路由配置</p><p><strong>TP框架</strong></p>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql基础操作</title>
      <link href="/2017/10/05/php-interview-prepare-mysql/"/>
      <url>/2017/10/05/php-interview-prepare-mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="Mysql基础操作"><a href="#Mysql基础操作" class="headerlink" title="Mysql基础操作"></a>Mysql基础操作</h4><p>连接和关闭:mysql -u用户名 -p密码 -h主机地址 -P端口号</p><p><strong>其他:</strong>\G,\c,\q,\s,\h,\d</p><p><strong>InnoDB 表引擎</strong></p><ul><li>默认事务型引擎，最重要最广泛的存储引擎</li><li>数据存储到共享表空间，可以通过配置分开</li><li>对主键查询的性能高于其他类型的存储引擎</li><li>内部做了很多的优化，从磁盘读取数据时自动创建哈希索引</li><li>通过一些机制和功能支持真正的热备份</li><li>支持崩溃后的安全回复</li><li>支持行级锁</li><li>支持外键</li></ul><p><strong>MyISAM表引擎</strong></p><ul><li>拥有全文索引、压缩、空间函数</li><li>不支持事务和行级锁，不支持崩溃后的安全回复</li><li>表存储在两个文件 MYD和MYI</li><li>设计简单，某些场景下性能很好</li></ul><p>其他表引擎<br>Archive、Blackhole、CSV</p><h3 id="Mysql锁机制"><a href="#Mysql锁机制" class="headerlink" title="Mysql锁机制"></a>Mysql锁机制</h3><p>基础概念：<br>表锁是日常开发中年常见的问题，因此是面试中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制问题</p><p>分为共享锁和排他锁</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><p>共享的，不堵塞，多个用户可以同时读取一个资源，互不干扰</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><p>排他的，一个写锁会阻塞其他的写锁和读锁，这样可以只允许一个人进行写入，防止其他用户进行的操作</p><h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>表锁，系统性能开销最小，会锁定整张表，MyISAM</p><p>行锁，最大程度的支持并发处理，但是也带来了最大的锁开销InnoDB</p><h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>服务器层不管事务管理，由下层的引擎实现，所以一个事务中，使用多种存储引擎不靠谱</p><p>在非事务的表上执行事务操作Mysql不会提醒不会报错</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>为以后的使用而保存的一条或者多条mysql语句的集合</p><p>存储过程就是有业务逻辑和流程的集合</p><p>可以在存储过程中创建表，更新数据、删除等等</p><p><strong>使用场景:</strong>：</p><p>通过把处理封装在容易使用的单元中，简化复杂的操作</p><p>保证数据的一致性</p><p>简化对变动的管理</p><a id="more"></a><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><p>提供给程序员和数据分析员来保证数据完整性的一种方法，他是与表事件相关的特殊的存储过程</p><p><strong>使用场景:</strong></p><p>通过数据库中的相关表实现级更改</p><p>实时健康空某张表的某个字段的更改而需要做出相应的处理</p><p>某些业务编号的生成</p><p>滥用会造成数据库以及应用程序的维护困难</p><h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>简单描述Mysql中索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响？</p><p>Mysql索引的基础和类型：</p><p>索引类似于数据的目录，想要找到一本书的某个特定的主题，需要先查找书的目录，定位对应的页码</p><p>存储引擎使用类似的方式进行数据查询，先去索引中找到对应的值，然后根据匹配的索引找到对应的数据行<br><strong>索引对性能的影响:</strong></p><ul><li><p>大大减小服务器需要扫描到数据量</p></li><li><p>帮助服务器避免排序和临时表</p></li><li>将随机I/O变为顺序I/O</li><li>大大提高查询速度，降低些的速度，占用磁盘</li></ul><p><strong>索引的使用场景</strong></p><ul><li>对于非常小的表，大部分情况下全表扫描效率更高</li><li>中到大型表，索引非常有效</li><li>特大型表，建立和使用索引的代价会随之增长，可以使用分区技术来解决</li></ul><p><strong>索引的类型</strong></p><ul><li>普通索引：基本的索引，没有任何的约束限制</li><li>唯一索引：与普通索引类型，但是具有唯一性约束</li><li>主键索引：特殊的唯一索引，不允许有空置</li><li>组合索引：将多个列组合在一起创建索引，可以覆盖多个列</li><li>外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作</li><li>全文索引：Mysql自带的全文索引只能用于MyISAM，并且只能对英文进行全文检索</li></ul><p><strong>主键索引和唯一索引的区别：</strong></p><ul><li><p>一个表只能有一个主键索引，可以有多个唯一索引</p></li><li><p>主键索引一定是唯一索引，唯一索引不是主键索引</p></li><li><p>主键可以与外键构成参照完整的约束防止数据不一致，唯一索引不可以</p></li></ul><p><strong>Mysql索引的创建原则:</strong></p><ul><li>最适合索引的列是出现在where子句的列，或者链接子句中的列，尾部是在select关键字后的列</li><li>索引列的技术越大，效果越好</li><li>对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间</li><li>根据情况创建复合索引，复合索引可以提高查询效率</li><li>避免创建过多的索引，会占用额外的磁盘空间，降低写操作的效率</li><li>主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用</li></ul><p><strong>Mysql索引的注意事项:</strong></p><ul><li><p>复合索引遵循前缀原则<br>key(a,b,c)<br>where a= 1 and b = 2 and c = 3<br>where a= 1 and b = 2<br>where a = 1<br>where b = 2 and c = 3</p></li><li><p>like查询，%不能在前，可以使用全文检索 where name like “%wang%” 索引不起作用</p></li><li>column is null 可以使用索引</li><li>如果mysql估计使用索引的时间比全表扫描要慢，会自动放弃索引</li><li>如果or前的条件的列有索引，后面的没有，索引都不会被用到</li><li>列类型是字符串时，一定要加引号，否则索引会失效</li></ul><h4 id="Mysql的SQL语句编写考点"><a href="#Mysql的SQL语句编写考点" class="headerlink" title="Mysql的SQL语句编写考点"></a>Mysql的SQL语句编写考点</h4><p>问题：有A(id,sex,par,c1,c2),B(id,age,c1,c2)两张表，其中A.id与B.id关联，现在要求写出一条SQL，将B中age&gt;50的记录的c1,c2更新到A表统一记录中的c1,c2字段中</p><p><strong>关联更新:</strong></p><p>两种方式：</p><p>UPDATE A,B SET A.C1 = B.C1,A.C2 = B.C2 WHERE A.ID = B.ID</p><p>UPDATE A INNER JOIN B ON A.ID = B.ID SET A.C1 = B.C1,A.C2 = B.C2</p><p>答案：</p><p>update A,B set A.c1 = B.c1,A.c2 = B.c2 where A.id = B.id and B.age &gt; 50;</p><p>update A inner join B on A.id = B.id SET A.c1 = B.c1,A.c2 = B.c2 where B.age &gt; 50 </p><p><strong>六种关联查询：</strong></p><ul><li>交叉连接 cross join<blockquote><p>select * from A,B,C</p></blockquote></li></ul><blockquote><p>select * from A cross join B cross join C</p></blockquote><p>没有任何的关联条件，结果是笛卡尔积，意义不大</p><ul><li>内连接   inner join<blockquote><p>select * from A,B where A.id = B.id</p></blockquote></li></ul><blockquote><p>select * from A inner join B on A.id = B.id</p></blockquote><p>多表中同事符合某种条件记录的集合，分为三类：</p><p>等值连接: ON A.id = B.id </p><p>不等值连接：ON A.id &gt; B.id</p><p>自连接：select * from A T1 inner join A T2 ON T1.id=T2.pid</p><p>INNER JOIN 可以缩写成 JOIN</p><ul><li>外连接 <blockquote><p>左外连接：LEFT OUTER JOIN 以左表位主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写为LEFT JOIN</p></blockquote></li></ul><blockquote><p>右外连接：RIGHT OUTER JOIN 简写为 right join</p></blockquote><ul><li>联合查询<blockquote><p>select <em> from A UNION select </em> from B UNION …</p></blockquote></li></ul><p>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的就是联合查询的列数要相等，相同的记录会合并</p><p>如果使用UNION ALL，不会合并重复行</p><ul><li>全连接<br>Mysql 不支持全连接</li></ul><blockquote><p>可以使用left join和union和right join 联合使用</p></blockquote><blockquote><p>select <em> from A left join B on A.id = B.id union select </em> from A right join B on A.id = B.id </p></blockquote><ul><li>嵌套查询</li></ul><p>用一条sql的结果作为另外一条sql语句的条件，效率不好把控,不建议使用</p><blockquote><p>select * from A where id in (select id from B)</p></blockquote><h4 id="Mysql查询优化"><a href="#Mysql查询优化" class="headerlink" title="Mysql查询优化"></a>Mysql查询优化</h4><p>项目中优化sql语句执行效率的方法，从哪些方面，sql语句性能如何分析？</p><ul><li>查找分析查询速度慢的原因</li><li>优化查询过程中的数据访问</li><li>优化长难的查询语句</li><li>优化特定类型的查询语句</li></ul><p><strong>分析SQL查询慢的方法:</strong></p><ul><li><p>记录慢查询日志</p><blockquote><p>分析查询日志，不要直接打开慢查询日志进行分析，这样比较浪费时间和精力，可以使用pt-query-digest工具进行分析</p></blockquote></li><li><p>使用show profile</p><blockquote><p>set profiling = 1 开启，服务器上执行的所有语句会检测消耗的时间，存到临时表中</p></blockquote></li></ul><p>show profiles;查看临时表</p><p>show profiles for query QUERY ID 查看某一条记录的具体时间分配</p><ul><li><p>show status</p><blockquote><p>show  status 会返回一些计数器，show global status 查看服务器级别的所有计数<br>有时候根据这些计数，可以猜出哪些操作代价较高或者消耗时间较多</p></blockquote></li><li><p>show processlist</p><blockquote><p>观察是否有大量的线程处于不正常的状态或者特使</p></blockquote></li><li><p>explain</p><blockquote><p>分析单条SQL语句，也可以使用desc 来达到一样的效果<br>desc select * from a</p></blockquote></li></ul><p><strong>优化查询过程中的数据访问</strong></p><ul><li>访问数据太多当值查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或者列</li><li>确认Mysql服务器是否在分析大量不必要的数据行</li></ul><p><strong>避免使用如下SQL:</strong></p><ul><li>查询不需要的记录，使用limit解决</li><li>多表关联返回全部列，指定A.id,A.name</li><li>总是取出全部列，select * 会让优化器完成索引覆盖扫描</li><li>重复查询相同的数据使用缓存</li></ul><p><strong>是否在扫描额外的记录：</strong></p><p>使用explain进行分析，如果发现查询需要扫描大量的数据但是只返回少数的行，可以通过以下技巧去优化：<br>使用索引覆盖扫描，把所有的列都放在索引中，这样索引不需要回标获取对应行就可以返回结果</p><p><strong>修改表数据库和表的结构，修改数据表的范式</strong></p><p><strong>重写sql，让优化器可以以更优的方式执行</strong></p><p><strong>优化长难的查询语句:</strong></p><blockquote><p>mysql 内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢的多<br>使用尽可能少的查询十号的，但是有的时候将一个大的查询分为几个小的查询也是有必要的</p></blockquote><ul><li><p>切分查询</p><blockquote><p>将一个大的查询分为多个小的相同的查询，比如一次性删除1000万的数据要比一次删除1万，暂停一会儿的方案跟那个价损耗服务器的开销</p></blockquote></li><li><p>分解关联查询</p><blockquote><p>可以将一条关联语句分解成多条sql来执行</p></blockquote></li></ul><blockquote><p>让缓存的效率更高</p></blockquote><blockquote><p>执行单个查询可以减少锁的竞争</p></blockquote><blockquote><p>在应用层做关联可以更容易对数据库进行拆分</p></blockquote><p><strong>优化特定类型的查询语句:</strong></p><ul><li>优化count()查询<blockquote><p>count(<em>)中的</em> 会忽略所有的列，直接统计所有的列数，因此不要使用count(列名)</p></blockquote></li></ul><blockquote><p>myisam中，没有任何where条件的count(*)非常快</p></blockquote><blockquote><p>当有where条件时，myisam的count统计不一定比其他表引擎快</p></blockquote><p>可以使用explain查询近似值，用近似值替代count(*)</p><p>增加汇总表</p><p>使用缓存</p><ul><li>优化关联查询<blockquote><p>确定on或者using自居的列上有没有索引</p></blockquote></li></ul><blockquote><p>确保group by 和order by 中只有一个表的列，这样才有可能使用索引</p></blockquote><ul><li><p>优化子查询</p><blockquote><p>用关联查询替代</p></blockquote></li><li><p>优化group by和distinct</p></li></ul><blockquote><p>这两种查询均可以使用所索引来优化，是最有效的优化方法</p></blockquote><blockquote><p>关联查询中，使用标识列进行分组的效率会更高</p></blockquote><blockquote><p>如果不需要order by，进行group by时使用 order by null ,mysql不会再进行文件排序</p></blockquote><blockquote><p>with rollup超级聚合</p></blockquote><ul><li>优化limit分页<blockquote><p>limit偏移量大的时候，查询效率较低</p></blockquote></li></ul><blockquote><p>可以记录上次查询的最大ID,下次查询时直接根据该ID来查询</p></blockquote><ul><li>优化union查询<blockquote><p>union all 的效率高于union，去重放到应用层去解决</p></blockquote></li></ul><p>首先说明如何定位低效sql</p><p>根据sql语句可能低效的原因做排查，从索引着手，考虑数据访问的问题，长难句的问题，特定类型优化的问题</p><h3 id="Mysql高可扩展和高可用"><a href="#Mysql高可扩展和高可用" class="headerlink" title="Mysql高可扩展和高可用"></a>Mysql高可扩展和高可用</h3><p>简述mysql分表操作和分区的工作原理，分别说说分区和分表的使用场景和各自的优缺点</p><p><strong>分区表的原理</strong></p><blockquote><p>对用户而言，分区表是一个独立的逻辑表，但是底层Mysql将其分层了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件</p></blockquote><p>创建表的时候使用partition by 子句定义每个enquiry存放的数据，执行查询的时候，优化器会根据分区定义过滤哪些没有我们需要数据的分区，这样查询只需要查询所需数据在的分区既可</p><p>主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据放在一起，而且如果想一次性删除整个去的数据也很方便</p><p><strong>适用场景：</strong></p><ul><li>表非常大，无法全部存在内存，或者旨在表的最后有热点数据，其他都是历史数据</li><li>分区表的数据更易维护，可以对独立的分区进行独立的操作</li><li>分区表的数据可以分布在不同的及其上，从而高效利用资源</li><li>可以使用分区避免某些特殊瓶颈</li><li>可以备份和恢复独立的分区</li></ul><p>限制：</p><ul><li>一个表中只能有1024个分区</li><li>5.1版本中，分区表表达式必须是证书，5.5可以使用列分区</li><li>无法使用外键</li><li>需要对现有表的结构进行修改</li><li>所有分去都必须使用相同的存储引擎</li><li>分区字段中如果有主键和唯一索引列，那么主键列和唯一列都必须包含进来</li><li>分区函数中可以使用的函数和表达式有一定的限制</li><li>某些存储引擎不支持分区</li><li>对于myisam分区表不能使用load index to cache </li><li>对于myisam使用分区表时需要打开更多的文件描述符</li></ul><p><strong>分库分表的原理</strong></p><blockquote><p>通过一些hash算法或者工具实现将一张数据垂直或者水平进行物理切分</p></blockquote><p><strong>使用场景：</strong></p><ul><li>单表记录的数据达到百万或者千万</li><li>可以解决表锁的问题</li></ul><p><strong>分表方式:</strong></p><ul><li>水平分割</li></ul><p>表很大，分割后可以降低在查询时需要读取的数据和索引的页数，同时也降低了索引的层数，提高查询速度</p><p>使用场景:表中的数据本身就有独立性，例如表中分别记录各个地区的数据或者不同时期的数据，也别是有数据常用，有些不常用</p><p>需要把数据存放在多个介质上</p><p>缺点：</p><ul><li>给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需要unoin操作</li><li>在许多数据库应用中，这种负责性会超过它带来的有点，查询时会增加读取一个索引层的磁盘次数</li></ul><p><strong>垂直分表：</strong></p><blockquote><p>把主键和列放在不同的表中</p></blockquote><p>使用场景：</p><ul><li>一个表中某些列常用，有些不常用</li><li>可以使数据量变小，一个数据页能存储更多的数据，查询时减少I/O次数</li></ul><p>缺点：</p><p>管理冗余列，查询所有的数据需要join操作</p><p>整体缺点：有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，不易于扩展</p><p>对于应用层来说，逻辑算法会增加开发成本</p><h4 id="Mysql复制原理和负载均衡"><a href="#Mysql复制原理和负载均衡" class="headerlink" title="Mysql复制原理和负载均衡"></a>Mysql复制原理和负载均衡</h4><p>在主库上把数据更改记录到二进制日志</p><p>从库将主库的日志复制到自己的中继日志中</p><p>从库读取中继日志中的事件，将其放在自己的库中执行</p><p><strong>解决的问题：</strong></p><ul><li><p>数据分布：随意停止或者开始复制，并在不同地理位置分布数据备份</p></li><li><p>负载均衡：降低单个服务器的压力</p></li><li><p>高可用和故障切换：帮助应用程序避免单点失败</p></li><li><p>升级测试：可以使用更高版的Mysql作为从库</p></li></ul><p>设定网站的用户数据量在千万级，但是活跃用户的数据量只有1%,如何通过优化数据库提高用户的访问速度？</p><h3 id="Mysql安全性考点"><a href="#Mysql安全性考点" class="headerlink" title="Mysql安全性考点"></a>Mysql安全性考点</h3><p>SQL语句应该考虑哪些安全性问题</p><p>SQL查询的安全方案</p><ul><li>使用预处理语句防SQL注入</li><li>写入数据库的数据要进行特殊字符的转义</li><li>查询错误信息不要返回给用户，将错误记录到日志</li></ul><h4 id="Mysql其他安全设置"><a href="#Mysql其他安全设置" class="headerlink" title="Mysql其他安全设置"></a>Mysql其他安全设置</h4><ul><li>定期做数据备份</li><li>不给查询用户root权限，合理分配权限</li><li>关闭远程访问数据库权限</li><li>修改root口令</li><li>删除多余用户</li><li>修改root用户名称</li><li>限制一般用户浏览其他库</li><li>限制用户对数据文件的访问权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP如何解决网站大流量与高并发的问题（四）</title>
      <link href="/2017/10/04/php-interview-prepare-hc-4/"/>
      <url>/2017/10/04/php-interview-prepare-hc-4/</url>
      
        <content type="html"><![CDATA[<h3 id="动态语言的并发处理"><a href="#动态语言的并发处理" class="headerlink" title="动态语言的并发处理"></a>动态语言的并发处理</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>什么是进程、线程、协程</li><li>什么是多进程、多线程</li><li>同步阻塞模型</li><li>异步非阻塞模型</li><li>php并发编程实践</li></ul><h4 id="什么是进程、线程、协程"><a href="#什么是进程、线程、协程" class="headerlink" title="什么是进程、线程、协程"></a>什么是进程、线程、协程</h4><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是一个执行中的程序</p><p>进程的三态模型：多道程序系统中，进程在处理器上交替运行，状态不断的发生变化</p><p>运行、就绪、阻塞</p><p>运行：当一个进程在处理机上运行时，则称该进程处于运行状态</p><p>就绪：当一个进程获得了除处理机以为的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态</p><p>阻塞:也成等待或睡眠状态，一个进程正在等待某一时间发生而暂停停止运行，这时即使把处理机分配给进程也无法运行<br><a id="more"></a></p><p><strong>进程的五态模型</strong> 对于一个世纪的系统，进程的状态以及转换更为复杂</p><p>新建态：对应于进程刚刚被创建时没有被提交的状态，并且等待系统完成创建进程的所有必要信息</p><p>终止态:进程已经结束运行，回收进行控制块以外的其他资源，并让其他进程从进程控制块中收集有关信息</p><p>活跃就绪:进程在主存并且可被调度的状态</p><p>静止就绪:进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程或者是挂起就绪进程具有更高的优先级，系统将把挂起就绪状态进程调回主存并转换为活跃就绪</p><p>活跃阻塞：指进程在主存，一旦等待的事件产生便进入活跃就绪状态</p><p>静止阻塞：进程对换到辅存时的阻塞状态，一旦等待事件产生便进入静止就绪状态</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>由于用户的并发请求，为每一个请求都创建一个进程显然是行不通的，从系统资源开销方面或者是响应用户请求的效率方面来看，因此操作系统中线程的概念便被引进了</p></blockquote><p>线程，有时候被称为轻量级进程</p><p>线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但是她可以同属一个进程的其他线程共享进程所拥有的全部资源</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</p><p>线程是程序中一个单一的顺序控制流程。进程内一个相对独立的可以调度的执行单元，是系统独立调度和分配CPU的基本单位，指运行程序的调度单位</p><p>在单个程序中同时运行多个线程完成不同的工作，称为多线程</p><p>每一个程序至少有一个线程，如果只有一个线程，那就是程序本身了</p><p>线程的三种状态：就绪状态，运行状态，阻塞状态</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><blockquote><p>协程是一种用户台的轻量级线程，协程的调度完全由用户控制。</p></blockquote><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><ul><li>线程是进程内的一个执行单元，进程内至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间</li><li>进程是资源分配和拥有的但愿，同一个进程内的线程共享进程的资源</li><li>线程是处理器调度的基本单位，但进程不是</li><li><p>两者均可并发执行</p></li><li><p>每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须已存在应用程序中，由应用程序提供多个线程执行控制</p></li></ul><h4 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h4><ul><li><p>一个线程可以有多个协程，一个进程也可以单独拥有多个协程</p></li><li><p>线程进程都是同步机制，而协程则是异步</p></li><li>协程可以保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ul><h4 id="什么是多进程、多线程"><a href="#什么是多进程、多线程" class="headerlink" title="什么是多进程、多线程"></a>什么是多进程、多线程</h4><p>多进程：同一时间里，同一个计算机系统中如果允许两个或者两个以上的进程处于运行状态，这就是多进程</p><p>多开一个进程，多分配一份资源，进程间通讯不方便</p><p>多线程：线程就是吧一个进程分诶很多片，每一个片都可以是一个独立的流程</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>单进程单线程：一个人在一个桌子上吃菜</p><p>单进程多线程：多个人在同一个桌子上吃采</p><p>多进程单线程：多个人每个人在自己的桌子上吃菜</p><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>多进程：最早的服务器端的程序都是通过多进程、多线程来解决并发的IO问题</p><p>一个请求创建一个进程，然后子进程进入循环同步阻塞的与客户端连接并且进行交互，手法处理数据</p><p>多线程：线程中可以直接向客户端连接发送数据</p><p>步骤：</p><p>创建一个socket</p><p>进入while循环，阻塞在进程accept操作上，等待客户端连接进入</p><p>主进程在多进程模式下通过fork创建子进程</p><p>多线程模型下可以创建子线程</p><p>子进程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向服务器发送数据</p><p>收到数据后服务器程序进程处理然后使用send向客户端发送响应</p><p>当客户端连接关闭时，子进程/子线程退出并销毁所有资源。主进程/线程会回收掉此子进程/线程</p><p>缺点：严重依赖进程来解决并发问题，会造成严重消耗</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3><p>现在各种高并发异步IO的服务器程序都是基于epoll实现的</p><p>IO复用异步非阻塞程序使用景点的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据首发，只是可以监听一个socket句柄的时间变化</p><blockquote><p>Add:添加一个socket 到 Reactor</p></blockquote><blockquote><p>Set：修改socket对应的时间，如可读可写</p></blockquote><blockquote><p>Del:从Reactor中移除,不再监听事件</p></blockquote><blockquote><p>Callback:事件发生后回调指定的函数</p></blockquote><p>Nginx:使用的就是多线程的Reactor</p><p>Swoole:使用的是多线程的Reactor和多进程的Worker</p><h3 id="PHP并发编程实践"><a href="#PHP并发编程实践" class="headerlink" title="PHP并发编程实践"></a>PHP并发编程实践</h3><ul><li>php的Swoole扩展<blockquote><p>php的异步、并行、高性能网络通信引擎，使用纯C语言编写，提供了PHP语言的异步多线程服务器，异步TCP/UDP网络客户端，异步Mysql，异步Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询</p></blockquote></li></ul><p>除了异步IO支持之外，Swoole为PHP多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多进程并发编程的工作</p><p>Swoole2.0支持了类似Go语言的协程，可以使用完全同步的代码实现异步程序</p><ul><li><p>Swoole的异步Mysql实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$db = new Swoole\MySQL;</span><br><span class="line">$server = array(&apos;host&apos;=&gt;&apos;&apos;,&apos;user&apos;=&gt;&apos;&apos;,&apos;password&apos;=&gt;&apos;&apos;,&apos;database&apos;=&gt;&apos;&apos;);</span><br><span class="line"></span><br><span class="line">$db-&gt;connect($server,function($db,$result) &#123;</span><br><span class="line">    $db-&gt;query(&apos;show tables&apos;,function(Swoole\MySQL $db,$result) &#123;</span><br><span class="line">        //do some thing;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>消息队列</p></li></ul><p>场景说明:用户注册后，需要发注册邮件和注册短信</p><p>串行方式:将注册信息写入数据库成功后，发送注册邮件，再发送注册短信</p><p>并行方式：将注册信息写入数据库成功后，发送注册邮件的同时发送注册短信</p><p>消息队列：将注册信息写入数据库成功后，将成功的信息写入队列，此时直接返回成功给用户，写入队列的时间非常短，可以忽略不计，然后异步发送邮件和短信</p><ul><li>应用解耦</li></ul><p>场景说明：用户下凡后，订饭系统需要通知库存系统</p><p>加入库存系统无法访问，则订饭减库存将失败，从而导致订单失败，订单系统与库存系统解耦</p><p>引用队列，用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户下单成功</p><p>订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存处理</p><ul><li>流量削峰</li></ul><p>应用场景：秒杀活动，流量瞬间激增，服务器压力大</p><p>用户发起请求，服务器接收后，先写入消息队列，加入消息队列长度超过最大值，则直接报错或者提示用户</p><p>后续的程序读取消息队列，去处理</p><p>控制请求量<br>缓解高流量</p><ul><li>日志处理</li></ul><p>应用场景：解决大量日志的传输</p><p>日志采集程序将程序写入消息队列，然后通过日志处理程序的订阅消费日志</p><ul><li>消息通讯</li></ul><p>应用场景：聊天室</p><p>多个客户端订阅同一个主题，进行消息发布和接收</p><ul><li>常见消息队列产品</li></ul><p>Kafka、ActiveMQ、ZeroMQ、RabbitMQ、Redis等</p><ul><li>接口的并发请求</li></ul><p>curl_multi_init</p>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> HighCurrency </tag>
            
            <tag> DynamicLanguage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP如何解决网站大流量与高并发的问题（三）</title>
      <link href="/2017/10/03/php-interview-prepare-hc-3/"/>
      <url>/2017/10/03/php-interview-prepare-hc-3/</url>
      
        <content type="html"><![CDATA[<h3 id="七层负载均衡的实现"><a href="#七层负载均衡的实现" class="headerlink" title="七层负载均衡的实现"></a>七层负载均衡的实现</h3><p>基于URL等应用层信息的负载均衡</p><p>Nginx的proxy是一个很强大的功能，实现了7层负载均衡</p><p>功能强大、性能卓越，运行稳定</p><p>配置简单灵活</p><p>能自动提出工作不正常的后端服务器</p><p>上传文件使用异步模式</p><p>支持多种分配策略，可以分配权重</p><p><strong>Nginx负载均衡有内置策略，扩展策略两种方式</strong></p><h4 id="内置策略"><a href="#内置策略" class="headerlink" title="内置策略"></a>内置策略</h4><ul><li>IP Hash<blockquote><p>流程和轮询很相似，是一种变相的轮询算法</p></blockquote></li><li>加权轮询<blockquote><p>首先将请求分给高权重的机器，知道该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器</p></blockquote></li></ul><p>当所有后端机器都down掉时，Nginx会立即将所有机器的标志位清成初始状态，以避免造成所有的机器都处在timeout的状态</p><a id="more"></a><h4 id="扩展策略"><a href="#扩展策略" class="headerlink" title="扩展策略"></a>扩展策略</h4><ul><li>fair 策略<blockquote><p>根据后端服务器的响应时间判断负载情况，从中选择出负载最轻的机器进行分流</p></blockquote></li><li>通用hash<blockquote><p>以nginx内置的变量为key进行hash</p></blockquote></li><li>一致性hash<blockquote><p>支持mem</p></blockquote></li></ul><h4 id="Nginx配置方案"><a href="#Nginx配置方案" class="headerlink" title="Nginx配置方案"></a>Nginx配置方案</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>nginx.conf</span><br><span class="line">http&#123;</span><br><span class="line">    upstream cluster&#123;</span><br><span class="line">        server srv1;</span><br><span class="line">        server srv2;</span><br><span class="line">        server srv3;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://cluster</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四层负载均衡实现"><a href="#四层负载均衡实现" class="headerlink" title="四层负载均衡实现"></a>四层负载均衡实现</h3><blockquote><p>通过报文中的目标和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器</p></blockquote><p>LVS实现服务器集群负载均衡有三种方式NAT,DR,TUN</p>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> Nginx </tag>
            
            <tag> HighCurrency </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP如何解决网站大流量与高并发的问题（二）</title>
      <link href="/2017/10/02/php-interview-prepare-hc-2/"/>
      <url>/2017/10/02/php-interview-prepare-hc-2/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p><strong>相关概念</strong></p><ul><li>什么是数据库缓存？</li><li>为什么使用缓存</li><li>使用MySQL查询缓存</li><li>使用Memcache缓存</li><li>使用Redis缓存</li></ul><h4 id="什么是数据库缓存"><a href="#什么是数据库缓存" class="headerlink" title="什么是数据库缓存"></a>什么是数据库缓存</h4><blockquote><p>Mysql等一些常见的关系型数据库的数据都存储在磁盘中，在高并发场景下，业务应用对mysql产生的增删改查的操作造成巨大的I/O开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生</p></blockquote><p>数据库缓存极大的解决数据库服务器的压力</p><p>提高应用数据的响应速度</p><p>常见的缓存形式：内存缓存、文件缓存，为了避免I/O开销，推荐使用内存缓存</p><h4 id="为什么使用缓存"><a href="#为什么使用缓存" class="headerlink" title="为什么使用缓存"></a>为什么使用缓存</h4><blockquote><p>缓存数据时为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度的降低对数据库服务器的访问压力</p></blockquote><p>用户请求–&gt;数据查询–&gt;连接数据库服务器并查询数据–&gt;将数据缓存起来(HTML,内存，JSON,序列化数据)–&gt;显示给客户端</p><p>用户再次请求或者新用户访问–&gt;数据查询–&gt;直接从缓存中获取数据–&gt;显示给客户端</p><p><strong>缓存方式的选择</strong></p><p><strong>缓存场景的选择</strong></p><p><strong>缓存数据的实时性</strong></p><p><strong>缓存数据的稳定性</strong></p><a id="more"></a><h4 id="MySQL查询缓存"><a href="#MySQL查询缓存" class="headerlink" title="MySQL查询缓存"></a>MySQL查询缓存</h4><p>启用mysql查询缓存：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type</span><br><span class="line"><span class="meta">#</span>查询缓存类型有0，1，2三个取值。0表示不使用缓存，1表示始终使用查询缓存，2表示按需使用查询缓存</span><br><span class="line"></span><br><span class="line">query_cache_type = 1</span><br><span class="line"><span class="meta">#</span>此时也可以关闭查询缓存</span><br><span class="line">select sql_no_cache * from table where condition;</span><br><span class="line"></span><br><span class="line">query_cache_type = 2</span><br><span class="line"><span class="meta">#</span> 按需查询缓存</span><br><span class="line">select sql_cache * from table where condition</span><br><span class="line"></span><br><span class="line">query_cache_size</span><br><span class="line"><span class="meta">#</span>默认情况下的query_cache_size为0，表示为查询缓存预留的内存位0，则无法使用查询缓存</span><br><span class="line"></span><br><span class="line">set global query_cache_size = 133443344;</span><br><span class="line"><span class="meta">#</span> 设置query_cache_size的大小</span><br></pre></td></tr></table></figure></p><p>查询缓存可以看做是sql文本和查询结构的映射</p><p>第二次查询的sql和第一次查询的sql必须完全相同才会使用缓存</p><p>show status like ‘Qcache_hits’ 查看命中次数</p><p>表的结构或者数据发生改变时，查询缓存中的数据不再有效</p><p><strong>清理缓存</strong></p><p><code>flush query cache;</code>清理查询缓存内存碎片</p><p><code>reset qyery cache;</code>从查询缓存中移除所有查询</p><p><code>flush tables;</code>关闭所有打开的表，同时该操作将会清空表缓存的内容</p><h4 id="使用Memcache缓存查询数据"><a href="#使用Memcache缓存查询数据" class="headerlink" title="使用Memcache缓存查询数据"></a>使用Memcache缓存查询数据</h4><blockquote><p>memcache 是一套分布式的高速缓存系统，由LiveJournal的Bard Fitzpatrict开发，但目前被许多网站使用以提升网站的访问速度，尤其是对一些大型的、需要频繁访问数据库的网站访问速度提升效果十分明显</p></blockquote><ul><li><p>工作原理</p><blockquote><p>memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像，视频，文件以及数据库检索的结构等。简单的说就是将数据调用到内存，然后从内存读取，从而大大提高读取速度。</p></blockquote></li><li><p>工作流程</p><blockquote><p>先检查客户端的请求数据是否在mem中，有的话直接返回，不在的话就去查库，把数据库中的数据返回给客户端，同时缓存到mem中</p></blockquote></li><li><p>方法</p></li></ul><p>获取： get(key)</p><p>设置：set（key）</p><p>删除：delete(key)</p><h3 id="Redis缓存查询数据"><a href="#Redis缓存查询数据" class="headerlink" title="Redis缓存查询数据"></a>Redis缓存查询数据</h3><ul><li>与memcache的区别</li></ul><blockquote><p>性能差别不大</p></blockquote><blockquote><p>Redis在2.0版本后增加了自己的VM特性，突破了物理内存的限制，mem可以修改最大可用内存，采用LRU算法</p></blockquote><blockquote><p>Redis依赖客户端实现分布式读写，mem本身没有数据冗余机制，Redis支持(快照，AOF)，依赖快照进行持久化，aof增强了可靠性的同时对性能有所影响</p></blockquote><blockquote><p>mem不支持持久化，在并发情境下用cas保证一致性，redis事务支持较弱，Redis支持多种类的数据类型</p></blockquote><blockquote><p>Redis用于数据量小的高性能的操作和运算上，mem用于在动态系统中减少数据库负载，提升性能，适合做缓存，提高性能</p></blockquote><h4 id="缓存其他数据"><a href="#缓存其他数据" class="headerlink" title="缓存其他数据"></a>缓存其他数据</h4><ul><li>Session<blockquote><p>将session存入到数据库来说是一种逆天的行为，可以存储到mem和redis中<br><code>session_set_save_handler</code>来修改存储地址</p></blockquote></li></ul><h2 id="MySQL数据库层的优化"><a href="#MySQL数据库层的优化" class="headerlink" title="MySQL数据库层的优化"></a>MySQL数据库层的优化</h2><p><strong>相关概念</strong></p><ul><li>优化方向</li><li>优化方案</li></ul><h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><ul><li>数据表结构设计的优化</li><li><p>数据表数据类型的优化</p><blockquote><p>字段使用什么样的数据类型更合适</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tinyint（0-255）、smallint、bigint（存储上千万的数字）#考虑空间的问题，考虑范围的问题，按需取</span><br><span class="line">char、varchar #考虑字符串长度是否固定</span><br><span class="line">enum #特定、固定的分类可以使用enum存储，效率更快</span><br><span class="line">IP地址的存储#ip2long将ip转换成长整型，long2ip</span><br></pre></td></tr></table></figure></blockquote></li><li><p>存储引擎的优化</p></li></ul><p>建立合适的索引，在什么时候效率最好？</p><blockquote><p>索引的创立原则： 不是越多越好，在合适的字段上创建合适的索引</p></blockquote><blockquote><p>复合索引的前缀的原则,like 查询%的问题，全表扫描优化，or条件索引使用情况，字符串类型索引失效问题</p><ul><li>数据库服务器架构的优化<br>分区操作</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP如何解决网站大流量与高并发的问题（一）</title>
      <link href="/2017/10/01/php-interview-prepare-hc-1/"/>
      <url>/2017/10/01/php-interview-prepare-hc-1/</url>
      
        <content type="html"><![CDATA[<h4 id="高并发的相关概念"><a href="#高并发的相关概念" class="headerlink" title="高并发的相关概念"></a>高并发的相关概念</h4><p>在某个时间点，有多少个访问量</p><p>如果一个系统的日PV在千万以上，有可能是一个高并发的系统</p><p><strong>QPS:</strong> 每秒钟请求或者查询的数量，在互联网领域，指每秒相应请求数(指HTTP请求)</p><p><strong>吞吐量:</strong> 单位时间处理的请求数量</p><p><strong>响应时间:</strong> 从请求发出到收到相应花费的时间</p><p><strong>PV:</strong> 综合浏览量 page view 页面浏览量或者点击量，一个访客在24小时之内的浏览量或者点击量</p><p><strong>UV:</strong> 独立访客unique visitor，一定时间范围内相同访客多次访问网站，只计算一独立个访客</p><p><strong>带宽:</strong> 计算带宽大小需关注两个指标，峰值流量和页面平均大小</p><p>日网站带宽 = PV/统计时间(s)<em> 平均页面大小(k) </em> 8</p><p>峰值一般是平均值的倍数，根据实际情况来定</p><p>QPS不等于并发连接数量</p><p>QPS是每秒HTTP的请求数量，并发连接数量是系统同事处理的请求数量</p><p>峰值每秒请求数(QPS) = (总PV数 <em> 80%) / (6小时秒数</em> 20%) </p><p>代表80%的访问量集中在20%的时间（28定律）</p><a id="more"></a><p><strong>压力测试:</strong></p><ul><li><p>压力测试</p><p>  常用的性能测试工具<br>  <strong>ab（apache benchmark）</strong></p><blockquote><p>模拟并发请求100次，总共请求5000次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ab -c 100 -n 5000 http://**.com</span><br><span class="line"></span><br><span class="line">//-c 并发数</span><br><span class="line">//-n 请求数量</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>注意事项:<br>测试机器与被测试机器分开 | 不要对线上服务做压力测试 | 观察测试功工具ab在机器以及被测试的前端机的CPU、网络等不超过75%</p></blockquote><ul><li><p>QPS达到50：不需要优化</p></li><li><p>QPS达到100： 假设关系型数据库的每次请求在0.01s完成，假设单个页面只有1个SQL,那么100QPS以为这1秒钟完成100次请求，但是此时我们并不能保证数据库查询能完成100次</p></li></ul><p>方案:数据库缓存层，数据库的负载均衡</p><ul><li>QPS达到800:</li></ul><p>假设我们使用百兆贷款，以为这网站出口的实际宽带是8M左右</p><p>假设每个页面只有10k，在这个并发下，百兆贷款已经吃完</p><p><strong>方案:</strong> CDN加速，负载均衡</p><ul><li>QPS达到1000:</li></ul><p>假设使用mem缓存数据，每个页面对mem的请求数远大于直接对db的请求</p><p>mem的悲观并发数在2w左右，但是有可能在之间内网宽带已经吃光，表现不稳定</p><p><strong>方案:</strong> 静态HTML缓存</p><ul><li>QPS达到2000:</li></ul><p>这个级别下，文件系统访问锁都成为了灾难</p><p><strong>方案:</strong> 做业务分离，分布式存储</p><p>测试能承受的最大并发</p><p>测试最大承受的QPS值</p><h4 id="高并发解决方案案例"><a href="#高并发解决方案案例" class="headerlink" title="高并发解决方案案例"></a>高并发解决方案案例</h4><ul><li><p>流量优化</p><p>  防盗链处理</p><p>  前端优化：减少http请求（合并css,js,图片）、添加异步请求、启用浏览器缓存和文件压缩、CDN加速、建立独立图片服务器</p><p>  服务端优化：页面静态化、并发处理</p><p>  数据库优化：数据库缓存(mem,redis),分库分表、分区操作、读写分离、负载均衡</p><p>  Web服务器优化：负载均衡</p></li></ul><h4 id="Web资源防盗链"><a href="#Web资源防盗链" class="headerlink" title="Web资源防盗链"></a>Web资源防盗链</h4><p><strong>盗链概念:</strong><br>盗链是指在自己的页面上展示一些并不在自己服务器上的内容</p><p>常见的小站盗用大战的图片、音乐、视频、软件资源</p><p>通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器</p><p><strong>防盗链的概念：</strong></p><p>防止别人通过一些技术手段盗用自己站点的资源，让资源在别人的站点上无法访问</p><p>可以大大减轻服务器以及带宽压力</p><p><strong>工作原理:</strong> 通过Referer或者签名，网站可以检测目标网页访问的来源网页</p><ul><li>Referer（有漏洞，可伪装）</li></ul><p>nginx 模块，ngx_http_referer_module用来阻挡来源非法的域名请求</p><p>Nginx指令valid_referers,全局变量$invalid_referer</p><p>valid_referers none|blocked|server_names|string…</p><p>none 代表为空时</p><p>blocked 代表来源头部不为空，但是里面的值被防火墙删除</p><p>server_names  代表信任的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referers none blocked immoc.com *.imooc.com</span><br><span class="line">    </span><br><span class="line">    #如果有不允许的访问，$invalid_referer 为1 ，重定向到错误页面</span><br><span class="line">    if($invalid_referer) &#123;</span><br><span class="line">        #return 403</span><br><span class="line">        rewrite ^/ http://www.imooc.com/403.jpg</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加密签名。使用第三方模块HttpAccessKeyModule实现Nginx防盗链</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">accesskey on|off 模块开关</span><br><span class="line"></span><br><span class="line">accesskey_hashmethod md5 | sha-1签名加密方式</span><br><span class="line"></span><br><span class="line">accesskey_arg GET参数名称呢</span><br><span class="line"></span><br><span class="line">accesskey_signature加密规则</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    accesskey on;</span><br><span class="line">    #加密方式</span><br><span class="line">    accesskey_hashmethod md5;</span><br><span class="line">    #获取参数的键</span><br><span class="line">    accesskey_arg sign;</span><br><span class="line">    #签名规则</span><br><span class="line">    accesskey_signatur 'jason$remoe_addr';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//md5(jason.ip)</span></span><br><span class="line"><span class="comment">//PHP中的加密规则</span></span><br><span class="line">$sign = md5(<span class="string">'jason'</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;img src = './logo.img?sign='.$sign.'&gt;"</span></span><br></pre></td></tr></table></figure><p>####减少HTTP的请求</p><p>性能黄金法则：只有10%-20%的最终用户响应时间花在接受请求的HTML上，剩下的80%-90%时间花在HTML文档所引用的js,css等组件上</p><p>如何改善：改善相应时间的最简单的途径就是减少组件的数量，并由此减少HTTP的请求量</p><p><strong>HTTP请求连接产生的开销</strong></p><p>域名解析–TCP连接–发送请求–等待–下载资源–解析时间</p><p><em>疑问？</em></p><p>DNS缓存、Keep-Alive会不会消除影响</p><p>查找DNS缓存也需要时间，多个缓存就要查找多次有可能缓存会被清楚</p><p>HTTP1.1协议规定请求只能串行发送，也就是100个请求必须依次逐个发送，前面的一个请求完成才能开始下个请求</p><h4 id="减少HTTP请求的方式"><a href="#减少HTTP请求的方式" class="headerlink" title="减少HTTP请求的方式"></a>减少HTTP请求的方式</h4><ul><li>图片地图：图片地图允许你在一个图片上关联多个URL,目标URL的选择取决于用户单击了图片上的那个位置</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">usemap</span>=<span class="string">"#map1"</span> <span class="attr">src</span>=<span class="string">"/image/image.git=f"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"map1"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">'rect'</span> <span class="attr">coords</span>=<span class="string">'0,0,31,31'</span> <span class="attr">href</span>=<span class="string">'javascipt:alert('</span><span class="attr">Home</span>')' <span class="attr">title</span>=<span class="string">'Home'</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">'rect'</span> <span class="attr">coords</span>=<span class="string">'36,0,66,31'</span> <span class="attr">href</span>=<span class="string">'javascipt:alert('</span><span class="attr">Cart</span>')' <span class="attr">title</span>=<span class="string">'Cart'</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">     ...</span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CSS Sprites</li></ul><p>CSS Sprites中文翻译CSS精灵，通过使用合并图片，通过指定的cssbackground-image 和backgroud-position来显示元素</p><ul><li>合并脚本和样式表</li></ul><p>使用外部的js和css文件引用的方式，因为这样比直接写在页面中性能要更好一点</p><p>把多个脚本合并成一个脚本，把多个css合并成一个css</p><ul><li>图片使用Base64编码减少页面请求数</li></ul><p>采用base64的编码方式将图片直接嵌入到网页中，而不是从外部载入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'data:image/gif;base64,/9j/4AAQSkZJ....'</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="浏览器缓存和数据压缩"><a href="#浏览器缓存和数据压缩" class="headerlink" title="浏览器缓存和数据压缩"></a>浏览器缓存和数据压缩</h3><p><em>高并发下只能通过提升服务器负责解决吗？</em></p><p><em>缓存只能做数据库缓存吗？</em></p><p>相关概念</p><p>HTTP缓存机制</p><p>前端代码和资源的压缩</p><h4 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h4><p>HTTP缓存模型中，如果请求成功会有三种情况</p><ul><li>200 from memory cache:直接从本地缓存中获取相应，最快速，最省流量，因为根本没有向服务器发送请求<br><strong>本地缓存</strong></li></ul><p>相关Header</p><blockquote><p>Pragma:HTTP1.0时代的遗留产物，该字段被设置为no-cache时没，会告知浏览器禁用本地缓存，每次都向服务器发送请求</p></blockquote><blockquote><p>Expires:HTTP1.0时代用来启动本地缓存的字段，expires值对应一个形如Thu，31 Dec 2037 23：55：55 GMT的格林威治时间，告诉浏览器缓存实现的时刻，如果时间还没到，标明缓存有效，无需发送请求，但是Expire是Nginx发送的，如果浏览器时间不准确，会造成很大的影响</p></blockquote><blockquote><p>Cache-Control:HTTP1.1针对Expires时间不一致的解决方案，运用Cache-Control告知浏览器缓存国企的时间间隔而不是时刻，即使具体时间不一致，也不影响缓存的管理<br>no-store:禁止浏览器缓存响应<br>no-cache：不允许直接使用本地缓存，先发起请求和服务器协商<br>max-age=delta-seconds:告知浏览器该相应本地缓存有效的最长期限，以秒为单位</p></blockquote><p><strong>优先级</strong><br>Pragma  &gt; Cache-Control &gt; Expires</p><ul><li>304 Not Modified:协商缓存，浏览器在本地没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端数据没有改变，浏览器从本地缓存相应，返回304</li></ul><p><strong>相关Header</strong></p><blockquote><p>Last-Modified:通知浏览器资源的最后修改时间</p></blockquote><blockquote><p>If-Modified-Since：得到资源的最后修改时间后，会将这个信息通过If-Modified-Since提交到服务器做检查，如果没有修改，返回304状态码</p></blockquote><blockquote><p>ETag:HTTP1.1推出，文件的指纹标识符，如果文件内容修改，指纹会改变</p></blockquote><blockquote><p>If-None-Math:本地缓存失效失败，会携带此值去请求服务端，服务端判断该资源是否改变，如果没有改变，直接使用本地缓存，返回304</p></blockquote><ul><li>200 OK 以上两种缓存失败，服务器返回完整相应数据，没有用到缓存，相对最慢</li></ul><h4 id="缓存策略的选择"><a href="#缓存策略的选择" class="headerlink" title="缓存策略的选择"></a>缓存策略的选择</h4><p>适合本地缓存的内容</p><ul><li>不变的图像，如logo，图标</li><li>js,css静态文件</li><li>下载的文件</li></ul><p>适合使用协商缓存</p><ul><li>HTML文件</li><li>经常替换的图片</li><li>经常修改的js,css文件</li><li>js,css文件的加载可以加入文件的签名来拒绝签名  index.css?签名|index.签名.js</li></ul><p>不建议缓存的内容</p><ul><li>用户隐私等敏感数据</li><li>经常改变的api数据接口</li></ul><h4 id="Nginx配置缓存策略"><a href="#Nginx配置缓存策略" class="headerlink" title="Nginx配置缓存策略"></a>Nginx配置缓存策略</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//获取响应头的If-Modified-Since参数</span></span><br><span class="line">$since = $_SERVER[<span class="string">'HTTP_IF_MODOFIED_SINCE'</span>];</span><br><span class="line"><span class="comment">//设置生存时间</span></span><br><span class="line">$lifttime = <span class="number">3600</span>;</span><br><span class="line"><span class="comment">//如果没有过期</span></span><br><span class="line"><span class="keyword">if</span> (strtotime($since)+ $lifetime &gt; time()) </span><br><span class="line">&#123;</span><br><span class="line">    header(<span class="string">'HTTP/1.1 304 Not Modified'</span>);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">header(<span class="string">'Last-Modified:'</span> . gmdate(<span class="string">'D,d M Y H:i:s'</span>,time()).<span class="string">'GMT'</span>)</span><br></pre></td></tr></table></figure><h5 id="本地缓存配置"><a href="#本地缓存配置" class="headerlink" title="本地缓存配置"></a>本地缓存配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_header指令：添加状态码为2xx和3xx的相应投信息</span><br><span class="line">add_header name value [always]</span><br><span class="line">可以设置Pragma/Expire/Cache-Control，可以继承</span><br><span class="line">expires指令:通知浏览器过期时间expires time;为负值时表示Cache-Control：no-cache</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> nginx.conf</span><br><span class="line">location ~.*\.(gif|jpg|png|flv|swf|rar|zip)$</span><br><span class="line">&#123;</span><br><span class="line">    valid_referers none blocked immoc.com *.imooc.com</span><br><span class="line">    </span><br><span class="line">    #如果有不允许的访问，$invalid_referer 为1 ，重定向到错误页面</span><br><span class="line">    if($invalid_referer) &#123;</span><br><span class="line">        #return 403</span><br><span class="line">        rewrite ^/ http://www.imooc.com/403.jpg</span><br><span class="line">    &#125;</span><br><span class="line">    # 缓存30天</span><br><span class="line">    expires 30d;</span><br><span class="line">    # 关闭etag</span><br><span class="line">    etag off;</span><br><span class="line">     # 添加cache-control</span><br><span class="line">    add_header</span><br><span class="line">    cache-control max-age=3600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端代码和资源压缩"><a href="#前端代码和资源压缩" class="headerlink" title="前端代码和资源压缩"></a>前端代码和资源压缩</h4><p>可以让资源文件更小</p><p>压缩方式：js,css,image,html代码压缩、<br>Gzip压缩</p><p>js压缩的原理一般是去掉多余的空格和回车，替换长变量名，简化写法</p><p>常用的压缩工具：UglifyJS、YUI Compressor<br>、Closure Compiler</p><p><strong>图片压缩：</strong></p><p>压缩工具：tinypng、JpegMini，ImageOptim</p><p><strong>Gzip压缩：</strong> 配置Nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gzip on|off</span><br><span class="line">gzip_buffers 32k</span><br><span class="line">gzip_disable</span><br><span class="line">gzip_min_length 200</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Interview Prepare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> Nginx </tag>
            
            <tag> PHP </tag>
            
            <tag> High Concurrency </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SEO优化 - 怎样建立高转化率的站点关键词</title>
      <link href="/2017/09/19/skills-seo/"/>
      <url>/2017/09/19/skills-seo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想要优化好一个网站，行业的分析，以及关键词的挖掘是必要的,有一定的关键词排名了,但是转化率和流量方面却很不理想这种情况大部分是只注重了有指数的关键词排名，而忽略了长尾关键词和一些没有指数但是可以带来巨大流量的关键词。</p></blockquote><p>网站大部分的搜索流量来自于单个搜索次数并不多的长尾关键词几乎是每个SEO都知道的事，越是大中型和门户型网站，长尾词的流量占比越重。这也是为什么很多SEO一直在呼喊要重视长尾词，要不停的的去拓展、去优化长尾词关键词的缘故。</p><p><strong>长尾关键词的挖掘也是一个比较繁琐的活，也是需要长期去做的事情.</strong></p><p>一般来讲，长尾关键词的拓展方式有以下几种：</p><h4 id="1、百度下拉框及相关搜索"><a href="#1、百度下拉框及相关搜索" class="headerlink" title="1、百度下拉框及相关搜索"></a>1、百度下拉框及相关搜索</h4><p>通过对百度下拉框的提示也能获取一些长尾关键词，这些词很大程度上会让用户直接搜索，因此也具有一定的访问量和转化效果，相关搜索也同样如此。但由于下拉框是单体搜索，扩展量比较小，不适宜于大批量的长尾词拓展。</p><h4 id="2、流量统计工具"><a href="#2、流量统计工具" class="headerlink" title="2、流量统计工具"></a>2、流量统计工具</h4><p>这也是仅次于搜索引擎后台的关键词又一大量获取真实并有价值的长尾词的方法。借助网站流量统计工具，不仅能分析出网站访问流量的来源，同时也能分析出用户的具体搜索行为，即用户是通过什么搜索词进入网站的。</p><h4 id="3、客服软件"><a href="#3、客服软件" class="headerlink" title="3、客服软件"></a>3、客服软件</h4><p>网站常见的客服软件，比如商务通、53kf、乐语等都提供关键词下载工具，这个绝对是用户真实搜索的关键词，并且具有相当的商业和转化价值。当然这其中很大一部分与后台流量统计工具的关键词有重叠，可作为筛选关键词之用。　　</p><p>如果可以的话，这些客服公司都有关键词库，不妨想办法要过来一些，扩充一下自身网站的关键词库，岂不美哉!</p><a id="more"></a><h4 id="4、问答平台及专业社区"><a href="#4、问答平台及专业社区" class="headerlink" title="4、问答平台及专业社区"></a>4、问答平台及专业社区</h4><p>像百度知道、搜搜问问、天涯问答这些综合型的问答平台，各行各业的问答都会有，虽然充斥着大量的推广和广告问答，但也有大量的真实用户的问答，所以很大一部分长尾词可能是我们头脑风暴所意想不到的，是继搜索引擎后台关键词工具和流量统计后台关键词挖掘之后的又一大长尾词拓展方法。</p><p>例如在百度知道搜索某目标关键词时，会出现许多与这个关键词相关的问题，而通过这许多相关问题再搜索时，又会出现更多关于这个关键词的问题，如此循环，可利用的长尾关键词资源可谓源源不绝。</p><p>一些专业社区或者论坛，如39健康是医疗行业寻找关键词的最佳去处。</p><blockquote><p>PS：以上4个方法也可以通过做个简单脚本程序来完成，这样可省去不少人力和时间，给批量挖掘长尾关键词带来方便。　　</p></blockquote><h4 id="5、搜索引擎提供的站长工具-关键词工具"><a href="#5、搜索引擎提供的站长工具-关键词工具" class="headerlink" title="5、搜索引擎提供的站长工具/关键词工具"></a>5、搜索引擎提供的站长工具/关键词工具</h4><p>谷歌的网站管理员工具和百度的凤巢竞价后台的关键词查询都有拓展关键词的功能，在国内来说，站长和SEO们还是以百度为主，所以百度竞价后台的关键词相对来说比较重要，搜索次数和拓展词量也相对真实可靠。</p><h4 id="6、站长工具及关键词软件"><a href="#6、站长工具及关键词软件" class="headerlink" title="6、站长工具及关键词软件"></a>6、站长工具及关键词软件</h4><p>目前站长工具像站长之家、爱站网、站长帮手都有类似的关键词拓展查询，并给出关键词的百度指数、搜索量以及优化难度，在一定程度上也能拓展出一定量的关键词。</p><h4 id="7、拆分组合"><a href="#7、拆分组合" class="headerlink" title="7、拆分组合"></a>7、拆分组合</h4><p>把网站目标关键词按一定形式进行拆分，然后在排列组合在一起，产生大批量的长尾关键词是很多网站的通用做法，这虽然并不像搜索引擎后台、流量统计以及问答平台这三种得到的关键词那样在真实性和价值性上性价比高，但同样可以获得大批量的关键词，全方位的把关键词覆盖住，是一种全面撒网式拓展方法。</p><h4 id="8、其他方法"><a href="#8、其他方法" class="headerlink" title="8、其他方法"></a>8、其他方法</h4><p>　　比如去竞争对手网站查看，可自制一些抓取工具把对手网站的长尾词抓取过来，进行去重、筛选等，存入关键词库。或者是利用百度指数、搜索风云榜这些工具，来搜集和拓展一些长尾词。</p><h4 id="总结一下几个挖掘长尾关键词的方法："><a href="#总结一下几个挖掘长尾关键词的方法：" class="headerlink" title="总结一下几个挖掘长尾关键词的方法："></a>总结一下几个挖掘长尾关键词的方法：</h4><pre><code>1. 产品核心词+品牌名称，通用型号;2. 产品核心词+商业模式;3. 产品核心词+服务方式;4. 产品核心词+企业性质;5. 产品核心词+错字别字，缩写;6. 产品服务核心词+搜索意图;7. 产品服务核心词+质地，特点，功能;8. 产品服务核心词+应用领域，地域名称。</code></pre><hr><blockquote><p>关键词是影响我们网站排名的重要因素，在做seo的时候，拥有自己独特的关键词库至关重要，但是怎么建立一套属于自己网站的关键词库，并且在众多网站中脱颖而出呢？</p></blockquote><p><strong>第一步：搜集行业相关的关键词</strong></p><p>关键词一般分为三类:目标关键词,长尾关键词和品牌关键词,既然是搜集关键词,这三类关键词一般我们是大小通吃的,但是长尾关键词一般都是由关键词词根拓展而来,所以抓住关键词的词根进行拓展才是比较正确的方法。</p><p>拓展方法包括:</p><pre><code>1.百度下拉，及相关搜索2.百度指数，及下拉。相关信息等。3.百度推广助手的使用。4.其他搜索词关键的时候用。</code></pre><p><strong>第二步：筛选选出的关键词</strong></p><p>经过搜集关键词这一步后，大量的关键词已经得到。接下来就是筛选出适合企业的关键词。比如：企业是搞网站建设的，那么关于网站建设流程，网站建设方案，网站建设报价就是第一批关键词。那么像网站建设软件，就不是用户的需求，或者说关联性不很紧密。毕竟企业想找个建站公司不关心用什么软件去建设网站的。</p><p><strong>第三步：对关键词进行归档</strong></p><p>　　这项工作就是比较细致的工作了。归档可以更合理的在网站布局关键词。哪些关键词需要布局到首页，栏目页，导航，内页。就一目了然。对网站内链，和外链也有很好地规划作用。</p><p><strong>第四步：从数据中找流量</strong></p><p>　　当网站优化到中期，已经有一定的流量后，可以根据网站流量数据做进一步的关键词词库完善工作。人们的搜索习惯不同，不可能把所有的关键词全部找出来。分析数据，只要能带来流量的关键词就要进一步添加到关键词词库。形成良性循环。网站优化自然会出效果。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2017/01/15/skills-linux-command/"/>
      <url>/2017/01/15/skills-linux-command/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配<br>grep、awk、sed等命令可以支持正则表达式</p></blockquote><blockquote><p>通配符用来匹配符合条件的文件名，通配符是完全匹配<br>ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的额通配符来进行匹配</p></blockquote><h3 id="GREP"><a href="#GREP" class="headerlink" title="GREP"></a>GREP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#Global Rugular Expression Print 全局正则表达式版本，强大的文本搜索工具，使用正则表达式搜索文本，并把匹配的行打印出来</span><br><span class="line">grep -v</span><br><span class="line">grep &apos;&apos;</span><br><span class="line">grep -r &apos;\[0\]:\[pay\]&apos; /www/logs/mabplaygameapi.gm99api.com/gameapi_ring/2017/ | head</span><br><span class="line">ps -ef|grep -w </span><br><span class="line">grep -c 统计数据</span><br><span class="line">grep &quot;a*&quot; file.txt匹配0个或者多个a</span><br><span class="line">grep &quot;aa*&quot; file.txt 匹配1个或者多个a</span><br><span class="line">grep -c &apos;\[0\]:\[pay\]&apos; 20180118.log //统计日志中发货的记录</span><br><span class="line"></span><br><span class="line">grep -oP 零宽断言</span><br><span class="line"></span><br><span class="line">先行断言   也叫零宽度正预测先行断言(?=exp)   --  表示匹配表达式前面的位置 </span><br><span class="line">(?=&#125;)</span><br><span class="line">匹配以&#125;结尾的所有前面的字符</span><br><span class="line">后发断言   也叫零宽度正回顾后发断言(?&lt;=exp)  --  表示匹配表达式后面的位置 </span><br><span class="line">(?&lt;=&#123;)</span><br><span class="line">匹配&#123;后面所有的字符</span><br><span class="line">负向零宽后发断言(?&lt;!exp)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#进程查看命令，显示瞬间进程(process)的动态</span><br><span class="line">ps -A 列出所有进程 等价于ps -e</span><br><span class="line">ps -a 显示一个终端的所有进程，除了会话引线</span><br><span class="line">ps -N 忽略选择</span><br><span class="line">ps -d 显示所有进程，但省略所有会话引线</span><br><span class="line">ps -x 显示没有控制终端的进程，同事显示各个命令的具体路径</span><br><span class="line">ps -p pid 进程使用cpu的时间</span><br><span class="line">ps -u uid or username选择有效的用户id或者用户名</span><br><span class="line">ps -g gid or groupname 显示组的所有进程</span><br><span class="line">ps U username 显示该用户下的所有进程，且显示各个命令的详细路径</span><br><span class="line">ps -f 全部列出，通常和其他选项连用，如 ps -fa or ps -fx</span><br><span class="line">ps -l 长格式</span><br><span class="line">ps -j 作业格式</span><br><span class="line">ps -o 用户自定义合适</span><br><span class="line">ps v 以虚拟存储器格式显示</span><br><span class="line">ps f 用你ASCII字符显示树状结构，表达程序间的相互关系</span><br><span class="line">ps s 采用程序信号的格式显示承诺需状况</span><br><span class="line">ps S 列出程序时，包括已中断的子程序资料</span><br><span class="line">ps -w 显示加宽，可以显示较多的咨询</span><br><span class="line">ps -au 显示较为详细的咨询</span><br><span class="line">ps -aux 显示所有包含其他使用者的进程</span><br><span class="line">ps -ef</span><br><span class="line">ps -m 显示所有线程</span><br><span class="line">ps -H 显示进程的层次，和其他命令何用 ps -Ha</span><br><span class="line">ps h 不显示第一行</span><br><span class="line">ps -ef | grep &apos;firefox&apos; | grep -v grep | awk &apos;&#123;print &quot;kill -9 &quot; $2&#125;&apos; | sh 批量杀掉某些进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USER 进程的属主；</span><br><span class="line">PID 进程的ID；</span><br><span class="line">PPID 父进程；</span><br><span class="line">%CPU 进程占用的CPU百分比；</span><br><span class="line">%MEM 占用内存的百分比；</span><br><span class="line">NI 进程的NICE值，数值大，表示较少占用CPU时间；</span><br><span class="line">VSZ 进程虚拟大小；</span><br><span class="line">RSS 驻留中页的数量；</span><br><span class="line">TTY 终端ID</span><br><span class="line">STAT 进程状态（有以下几种）</span><br><span class="line">D 无法中断的休眠状态（通常 IO 的进程）；</span><br><span class="line">R 正在运行可中在队列中可过行的；</span><br><span class="line">S 处于休眠状态；</span><br><span class="line">T 停止或被追踪；</span><br><span class="line">W 进入内存交换（从内核2.6开始无效）；</span><br><span class="line">X 死掉的进程（从来没见过）；</span><br><span class="line">Z 僵尸进程；</span><br><span class="line">&apos;process_users_info&apos; |grep -v &apos;grep&apos;</span><br><span class="line"></span><br><span class="line">grep -oP &quot;&#123;(?&lt;=&#123;)[^&#123;&#125;]*(?=&#125;)&#125;&quot; 20180108.log //获取json字符串</span><br></pre></td></tr></table></figure><!--more--><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入、一个或者多个文件或者其他命令的输出，支持用户自定义函数和动态正则表达式等。awk有很多内建的功能，比如数组、函数等</span><br><span class="line"></span><br><span class="line">常用命令</span><br><span class="line">-F fs 指定输入分隔符，fs可以是字符串或者正则表达式，如-F:</span><br><span class="line"></span><br><span class="line">-v var=value 赋值一个用户定义变量，将外部变量传递给awk</span><br><span class="line"></span><br><span class="line">-f scripfile 从脚本文件中读取awk命令</span><br><span class="line"></span><br><span class="line">-m[fr] val 对val值设置内在限制</span><br><span class="line"></span><br><span class="line">-mf 选项限制分配给val的最大块数目；</span><br><span class="line">-mr选项限制记录的最大数目</span><br><span class="line">cat  host.php.log | grep register | awk -F &quot;,&quot; &apos;&#123;print $6&#125;&apos; | awk -F &quot;:&quot; &apos;&#123;sum +=$2&#125; END &#123;print sum/NR&#125;&apos;</span><br><span class="line"></span><br><span class="line">awk -F &apos;orderID&quot;&apos; &apos;&#123;print $2&#125;&apos; 20180108.log | awk -F &apos;&quot;&apos; &apos; &#123;if ($2&gt;0) print $2&#125;&apos;//查找日志中的订单号</span><br></pre></td></tr></table></figure><h3 id="KILL"><a href="#KILL" class="headerlink" title="KILL"></a>KILL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill</span><br></pre></td></tr></table></figure><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System ActivityReporter系统活动情况报告</span><br><span class="line">sar -A 所有报告的总和</span><br><span class="line">sar -b 显示I/O和传递速率的统计信息</span><br><span class="line">sar -B 显示换页状态</span><br><span class="line">sar -d 输出每一块磁盘的使用信息</span><br><span class="line">sar -e:设置显示报告的结束时间</span><br><span class="line">sar -f:从制定的文件读取报告</span><br><span class="line">sar -i:设置状态信息刷新的间隔时间</span><br><span class="line">sar -P:报告每个CPU的状态</span><br><span class="line">sar -R:显示内存状态</span><br><span class="line">sar –u:输出cpu使用情况和统计信息</span><br><span class="line">sar –v:显示索引节点、文件和其他内核表的状态</span><br><span class="line">sar -w:显示交换分区的状态</span><br><span class="line">sar -x:显示给定进程的装</span><br><span class="line">sar -r:报告内存利用率的统计信息</span><br></pre></td></tr></table></figure><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">I/O statitics的缩写，iostat工具将对系统的磁盘操作活动进行监视，它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况，同vmstat一样</span><br><span class="line"></span><br><span class="line">-c 显示CPU使用情况</span><br><span class="line">-d 显示磁盘使用情况</span><br><span class="line">-k 以 KB 为单位显示</span><br><span class="line">-m 以 M 为单位显示</span><br><span class="line">-N 显示磁盘阵列(LVM) 信息</span><br><span class="line">-n 显示NFS 使用情况</span><br><span class="line">-p[磁盘] 显示磁盘和分区的情况</span><br><span class="line">-t 显示终端和CPU的信息</span><br><span class="line">-x 显示详细信息</span><br><span class="line">-V 显示版本信息</span><br><span class="line">``` </span><br><span class="line">### WC</span><br></pre></td></tr></table></figure><p>wc<br>用来计算数字，利用wc指令我们可以计算文件的Byte数、字数或是列数<br>wc -l 只显示列数line<br>wc -w 只显示行数words<br>wc -c 只显示Bytes数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### xargs</span><br></pre></td></tr></table></figure></p><p>xargs 给其他命令传递参数的一个过滤器</p><p>#使用xargs执行mv 将 . 下后缀为.log的文件移动到test4文件夹下<br>find . -name “*.log” | xargs -i mv {} test4</p><p>#用grep命令在所有的普通文件中搜索hostname这个词<br>find . -type f -print | xargs grep “hostname”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### chown</span><br></pre></td></tr></table></figure></p><p>给用户组授权某个文件的权限<br>chown -R www:www floder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### find</span><br><span class="line">find . -name abc</span><br><span class="line">find . -name abc?</span><br><span class="line">fine . -name &quot;abc*&quot;</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]# date +%Y/%m/%d-%H:%M:%S<br>2018/03/14-21:04:56<br>[root@localhost ~]# date<br>2018年 03月 14日 星期三 21:04:58 CST<br>[root@localhost ~]#<br>[root@localhost ~]# cal<br>      三月 2018<br>日 一 二 三 四 五 六<br>             1  2  3<br> 4  5  6  7  8  9 10<br>11 12 13 14 15 16 17<br>18 19 20 21 22 23 24<br>25 26 27 28 29 30 31</p><p>[root@localhost ~]# cal 2018<br>                               2018</p><pre><code>一月                   二月                   三月</code></pre><p>日 一 二 三 四 五 六   日 一 二 三 四 五 六   日 一 二 三 四 五 六<br>    1  2  3  4  5  6                1  2  3                1  2  3<br> 7  8  9 10 11 12 13    4  5  6  7  8  9 10    4  5  6  7  8  9 10<br>14 15 16 17 18 19 20   11 12 13 14 15 16 17   11 12 13 14 15 16 17<br>21 22 23 24 25 26 27   18 19 20 21 22 23 24   18 19 20 21 22 23 24<br>28 29 30 31            25 26 27 28            25 26 27 28 29 30 31</p><p>[root@localhost ~]# cal 10 2018<br>      十月 2018<br>日 一 二 三 四 五 六<br>    1  2  3  4  5  6<br> 7  8  9 10 11 12 13<br>14 15 16 17 18 19 20<br>21 22 23 24 25 26 27<br>28 29 30 31</p><p>[root@localhost ~]# echo $LANG<br>zh_CN.UTF-8<br>[root@localhost ~]# bc 计算器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### init</span><br></pre></td></tr></table></figure></p><p>init 0 关机<br>init 3 纯命令行<br>init 5 图形界面<br>init 6 重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 用户和用户组</span><br></pre></td></tr></table></figure></p><p>root@localhost ~]# ls -al<br>总用量 2560<br>dr-xr-x—.  7 root root    4096 3月  14 21:20 .<br>dr-xr-xr-x. 22 root root    4096 1月   8 10:41 ..<br>-rw——-.  1 root root    3334 11月 11 17:52 anaconda-ks.cfg<br>-rw——-   1 root root   12288 3月   6 13:24 .anaconda-ks.cfg.swp<br>-rw——-.  1 root root   14159 3月  14 21:20 .bash_history<br>-rw-r–r–.  1 root root      18 5月  20 2009 .bash_logout<br>-rw-r–r–.  1 root root     176 5月  20 2009 .bash_profile<br>[     1   ][   2  ][  3   ][   4  ][   5    ][   6    ][  7   ]<br>[ 权    限][连接数][所有者][用户组][文件容量][修改日期][文件名]<br>连接数：有多少文件名连接到此节点<br>文件容量：默认单位为B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><ul><li>rwx           rwx              —<br>[1]           [2]           [3]              [4]<br>文件类型  所有者权限  所有用户组权限  其他人对此人间权限<br>r 读 ： 4<br>w 写 :  2<br>x 执行 : 1<ul><li>无权限<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 改变文件属性与权限</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>chgrp 改变文件所属用户组 change group<br>要被改变的组名必须要在/etc/group文件内存在才可以<br>chgrp [group] [file]<br>chown 改变文件所有者     change owner<br>chown [user] [file]<br>chown [user:group] [file] 同时修改用户组和所有者<br>chown [.group] [file]     单独修改用户组<br>chmod 改变文件权限       change </p><p>Linux文件的基本权限有9个分别是 owner、group、others 三种身份各有自己的read、write、execute权限</p><p>owner rwx 4+2+1 7<br>group rwx 4+2+1 7<br>others — 0+0+0 0</p><p>chmod -R 777 [file] 所有都是最高权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Linux目录配置标准FHS</span><br><span class="line"></span><br><span class="line"> | 可分享的 | 不可分享的</span><br><span class="line">---|---|---</span><br><span class="line">不变的 |/usr(软件放置处)| /etc(配置文件)</span><br><span class="line">       |/opt(第三方软件)|/boot(开机与内核文件)</span><br><span class="line">---|---|---</span><br><span class="line">可变动的| /var/mail(用户邮件信箱)| /var/run(程序相关)</span><br><span class="line">        |/var/spool/news(新闻组)|/var/lock(程序相关)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 系统定时任务</span><br><span class="line">__crontab命令:__</span><br><span class="line"></span><br><span class="line">crontab -e创建</span><br><span class="line"></span><br><span class="line">*****命令（分时日月周）</span><br><span class="line"></span><br><span class="line">__at命令:__</span><br><span class="line"></span><br><span class="line">一次执行</span><br><span class="line"></span><br><span class="line">#at 2:00 tomorrow</span><br><span class="line"></span><br><span class="line">at&gt;/Home/Json/do_job</span><br><span class="line">at&gt;Crtl+d</span><br><span class="line">### vim/vi 编辑器</span><br><span class="line">一般模式:删除、复制、粘贴</span><br><span class="line"></span><br><span class="line">切换编辑模式:i,I,o,O,a,A,r,R</span><br><span class="line"></span><br><span class="line">切换命令模式:,/,?</span><br><span class="line"></span><br><span class="line">移动光标:ctrl + f,crtl + b,0 home,$ end,G，gg,N +enter</span><br><span class="line"></span><br><span class="line">查找替换:/word,?word,</span><br><span class="line"></span><br><span class="line">:n1,n2s/word1/word2/g</span><br><span class="line"></span><br><span class="line">删除复制粘贴:x,X、dd、ndd、yy、nyy、p、P、crtl+r,.</span><br><span class="line"></span><br><span class="line">保存退出：wq</span><br><span class="line"></span><br><span class="line">__配置:__</span><br><span class="line"></span><br><span class="line">setnu,setnonu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### shell</span><br><span class="line"></span><br><span class="line">赋予权限，直接执行 </span><br><span class="line"></span><br><span class="line">chmod + x test.sh</span><br><span class="line"></span><br><span class="line">source 命令</span><br><span class="line"></span><br><span class="line">编写基础：</span><br></pre></td></tr></table></figure></p><p>#!/bin/sh</p><p>#指定脚本解释器<br>…<br>…</p><p>#编写具体功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 查看Linux版本</span><br><span class="line">`cat /proc/version`</span><br><span class="line"></span><br><span class="line">`uname -a`</span><br><span class="line"></span><br><span class="line">`uname -r`</span><br><span class="line"></span><br><span class="line">- 列出所有版本信息,</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]# lsb_release -a</p><p>LSB Version:    :core-3.1-amd64:core-3.1-ia32:core-3.1-noarch:graphics-3.1-amd64:graphics-3.1-ia32:graphics-3.1-noarch</p><p>Distributor ID: CentOS</p><p>Description:    CentOS release 5.5 (Final)</p><p>Release:        5.5</p><p>Codename:      Final</p><p>注:这个命令适用于所有的linux，包括RedHat、SUSE、Debian等发行版。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2) 执行cat</span><br></pre></td></tr></table></figure><p>/etc/issue,例如如下:</p><p>[root@localhost ~]# cat /etc/issue</p><p>CentOS release 5.5 (Final)</p><p>Kernel r on an m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3) 执行cat</span><br></pre></td></tr></table></figure><p>/etc/redhat-release ,例如如下:</p><p>[root@localhost ~]# cat /etc/redhat-release</p><p>CentOS release 5.5 (Final)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查看系统是64位还是32位:</span><br></pre></td></tr></table></figure></p><p>1.<br>getconf LONG_BIT or getconf WORD_BIT</p><p>[root@localhost ~]# getconf LONG_BIT</p><p>64<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>2、file /bin/ls</p><p>[root@localhost ~]# file /bin/ls</p><p>/bin/ls: ELF 64-bit LSB executable, AMD x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9, stripped<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>3、lsb_release  -a</p><p>[root@localhost ~]# lsb_release -a</p><p>LSB Version:    :core-3.1-amd64:core-3.1-ia32:core-3.1-noarch:graphics-3.1-amd64:graphics-3.1-ia32:graphics-3.1-noarch</p><p>Distributor ID: CentOS</p><p>Description:    CentOS release 5.5 (Final)</p><p>Release:        5.5</p><p>Codename:      Final</p><p>4、或者是使用查看文件的方法。</p><p>vim /ect/issue</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
